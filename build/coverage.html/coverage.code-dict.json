{"/home/travis/build/npmtest/node-npmtest-strong-agent/test.js":"/* istanbul instrument in package npmtest_strong_agent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-agent/lib.npmtest_strong_agent.js":"/* istanbul instrument in package npmtest_strong_agent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_strong_agent = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_strong_agent = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-agent/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-strong-agent && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_strong_agent */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_strong_agent\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_strong_agent.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_strong_agent.rollup.js'] =\n            local.assetsDict['/assets.npmtest_strong_agent.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_strong_agent.__dirname + '/lib.npmtest_strong_agent.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/main.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nmodule.exports = require('./agent');\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/agent.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nif ('STRONGAGENT' in global) {\n  module.exports = global.STRONGAGENT;\n  return;\n}\n\nvar assert = require('assert');\nvar fs = require('fs');\nvar util = require('util');\nvar events = require('events');\nvar semver = require('semver');\n\nvar addon = require('./addon');\nvar customStats = require('./custom-stats');\nvar debug = require('./debug')();  // DEBUG=strong-agent\nvar defaults = require('./config');\nvar dyninst = require('./dyninst');\nvar dyninstMetrics = require('./dyninst-metrics');\nvar json = require('./json');\nvar loadLicense = require('./license');\nvar proxy = require('./proxy');\nvar counts = require('./counts');\nvar info = require('./info');\nvar metrics = require('./metrics');\nvar loop = require('./loop');\nvar moduleDetector = require('./module-detector');\nvar topFunctions = require('./top-functions');\n\n// Profilers\nvar cpuProf = require('./profilers/cpu');\nvar memProf = require('./profilers/memory');\n\nvar tiers = require('./tiers');\n\nvar agentPackage = require('../package.json');\n\nfunction Agent() {\n  events.EventEmitter.call(this);\n  this.started = false;\n  // Setup default config for apps that just call .use()\n  this.configure();\n  this.cpuinfo = require('./cpuinfo');\n  this.internal = new events.EventEmitter;\n  this.internal.supports = {\n    watchdog: !!(addon && addon.watchdogActivationCount),\n  };\n  this.metrics = new Metrics(this);\n  if (addon && addon.lrtime) {\n    // Linux-only CLOCK_MONOTONIC_COARSE time function.  Returns the\n    // seconds and nanoseconds in an array, like process.hrtime() does,\n    // but the precision will usually be no better than one millisecond.\n    //\n    // The coarse clock is normally at least two times faster to query\n    // and may be 10-100x faster when the system clock is virtualized\n    // and has to be emulated by the host operating system.\n    //\n    // CLOCK_MONOTONIC_COARSE was added in 2.6.32.  When the coarse clock\n    // is unavailable or unsuitable, CLOCK_MONOTONIC is used instead.\n    this.internal.lrtime = addon.lrtime;\n  }\n}\nutil.inherits(Agent, events.EventEmitter);\n\nAgent.prototype.profile = function(userKey, appName, options) {\n  var self = this;\n\n  if (this.started) {\n    this.warn('profiling has already started');\n    return;\n  }\n\n  if (options == null) {\n    options = {};\n  }\n  options.apiKey = userKey;\n  options.appName = appName;\n\n  this.quiet = !!options.quiet;\n\n  this.configure(options);\n  var config = this.config;\n\n  if (!config.key || !config.appName) {\n    if (!config.key) return;\n    this.warn(\n        'Application name not found, StrongOps dashboard reporting disabled.');\n    return;\n  }\n\n  this.notice('dashboard is at https://strongops.strongloop.com');\n\n  var loopbackPath = 'loopback';\n  var loopbackVersion = moduleDetector.detectModule(loopbackPath);\n  var version = agentPackage.version;\n\n  if (!addon) {\n    version += ' (no-addon)';\n  }\n\n  this.start();\n\n  return this;\n};\n\nAgent.prototype.configure = function(options) {\n  options = options || {};\n  var apiKey = options.apiKey;\n  var appName = options.appName;\n  this.config = defaults.configure(apiKey, appName, options, process.env);\n  this.config.license.forEach(this.addLicense, this);\n  this.strongTracerInstrument =\n      options.strongTracer ? options.strongTracer.tracer : null;\n};\n\nAgent.prototype.addLicense = function(lic) {\n  var license = loadLicense(lic);\n  if (license.covers('agent')) {\n    // TODO: filter duplicates on license.key\n    this.licenses = this.licenses || [];\n    this.licenses.push(license);\n  }\n};\n\nAgent.prototype.licensed = function(feature) {\n  var now = new Date();\n  var licensed = this.licenses && this.licenses.some(function(lic) {\n    return lic.covers('agent', feature, now);\n  });\n  debug('agent feature %j licensed? %j licenses %j',\n        feature, licensed, this.licenses);\n  return licensed;\n};\n\nAgent.prototype.start = function() {\n  var config = this.config;\n\n  if (this.started) return;\n\n  if (!addon) {\n    this.notice('native addon missing, install a compiler');\n  }\n\n  this.notice('v%s profiling app \\'%s\\' pid \\'%d\\'', agentPackage.version,\n              config.appName, process.pid);\n\n  assert(config.baseInterval, 'config is missing defaults');\n  proxy.init(this);\n  cpuProf.init(this);\n  info.init(this);\n  this.dyninst.metrics = dyninstMetrics.init(this, dyninst);\n\n  this.prepareProbes();\n  this.prepareProfilers();\n  this.prepareClusterControls();\n  this.preparePoll(config);\n\n  this.started = true;\n\n  this.info('started profiling agent');\n};\n\nAgent.prototype.stop = function() {\n  this.started = false;\n};\n\nAgent.prototype.prepareProbes = function() {\n  var probes = {};\n  var probe_files = fs.readdirSync(__dirname + '/probes');\n\n  probe_files.forEach(function(file) {\n    var m = file.match(/^(.*)+\\.js$/);\n    if (m && m.length == 2) probes[m[1]] = true;\n  });\n\n  var original_require = module.__proto__.require;\n  module.__proto__.require = function(name) {\n    var target_module = original_require.apply(this, arguments);\n\n    // loopback-boot loads modules using full path, e.g.\n    // '/path/to/app/node_modules/strong-express-metrics'\n    var pathMatch = name.match(/[\\/\\\\]node_modules[\\/\\\\]([^\\\\\\/]+)$/);\n    if (pathMatch) name = pathMatch[1];\n\n    if (target_module && !target_module.__required__ && probes[name]) {\n      debug('instrumenting \"%s\" module with probe', name);\n      target_module.__required__ = true;\n      target_module = require('./probes/' + name)(target_module);\n    }\n\n    return target_module;\n  };\n};\n\nAgent.prototype.prepareProfilers = function() {\n  var self = this;\n  memProf.init(this);\n\n  // Allow memory profiling events to be triggered from server\n  this.internal.on('memory:start', function() {\n    if (memProf.enabled) {\n      self.warn('memory profiler has already been started');\n      self.internal.emit('profile:start', 'memory');\n      return;\n    }\n    if (memProf.start()) {\n      self.info('starting memory profiler');\n      self.internal.emit('profile:start', 'memory');\n    } else {\n      self.warn('failed to start memory profiler: no compiled addon');\n      self.internal.emit('profile:unsupported', 'memory');\n    }\n  });\n\n  self.internal.on('memory:stop', function(/*rowid*/) {\n    self.info('stopping memory profiler');\n    memProf.stop();\n    // XXX(bnoordhuis) Probably obsolete now that the collector is gone\n    // but test/test-profile-start-stop.js tests for it and it's possible\n    // strong-pm depends on it in some capacity.  I'm leaving it in for now.\n    self.internal.emit('profile:stop:v2', 'memory', {});\n  });\n\n  // Allow cpu profiling events to be triggered from server\n  this.internal.on('cpu:start', function() {\n    if (cpuProf.enabled) {\n      self.warn('cpu profiler has already been started');\n      self.internal.emit('profile:start', 'cpu');\n      return;\n    }\n    if (cpuProf.start()) {\n      self.info('starting cpu profiler');\n      self.internal.emit('profile:start', 'cpu');\n    } else {\n      self.warn('failed to start cpu profiler: no compiled addon');\n      self.internal.emit('profile:unsupported', 'cpu');\n    }\n  });\n\n  self.internal.on('cpu:stop', function(rowid) {\n    var data = cpuProf.stop();\n    if (data) {\n      self.info('strong-agent stopping cpu profiler run %d', rowid);\n    } else {\n      self.info('strong-agent cpu profiler run %d already stopped', rowid);\n    }\n\n    // XXX(bnoordhuis) Probably obsolete now that the collector is gone\n    // but test/test-profile-start-stop.js tests for it and it's possible\n    // strong-pm depends on it in some capacity.  I'm leaving it in for now.\n    self.internal.emit('profile:stop:v2', 'cpu', data || {});\n  });\n};\n\nAgent.prototype.poll = function() {\n  var data;\n\n  this.emit('poll::start');\n\n  if (data = counts.poll()) {\n    this.internal.emit('counts', data);\n  }\n\n  if (data = loop.poll()) {\n    this.internal.emit('loop', data);\n  }\n\n  if (data = memProf.poll()) {\n    this.internal.emit('instances', data);\n  }\n\n  if (data = topFunctions.poll()) {\n    this.internal.emit('topCalls', data);\n  }\n\n  if (data = tiers.poll()) {\n    this.internal.emit('tiers', data);\n  }\n\n  info.poll();  // Returns nothing, recorded as CPU/heap/connection metrics.\n\n  if (data = metrics.poll()) {\n    this.internal.emit('metrics', data);\n  }\n\n  if (addon && addon.watchdogActivationCount) {\n    this.internal.emit('watchdogActivationCount',\n                       addon.watchdogActivationCount());  // Resets the counter.\n  }\n\n  this.emit('poll::stop');\n};\n\nAgent.prototype.preparePoll = function(config) {\n  setInterval(this.poll.bind(this), config.baseInterval).unref();\n  // Make 'topCalls' events available to strong-supervisor.  This is a\n  // semi-internal API; it's intended for SL tooling, not general use.\n  this.internal.on('topCalls', this.emit.bind(this, 'topCalls'));\n\n  // Forward API usage metrics to strong-supervisor.\n  // This is a semi-internal API intended for SL tooling, not general use\n  this.internal.on(\n    'express:usage-record',\n    this.emit.bind(this, 'express:usage-record'));\n};\n\n// First call will have null control, and clustering configuration will be set\n// to {enabled: false}. Later, the strong-cluster-control probe may call this\n// with s-c-c as the argument.\nAgent.prototype.prepareClusterControls = function(control) {\n  var self = this;\n\n  if (self._strongClusterControl) {\n    // Ignore multiple initialization\n    return;\n  }\n\n  var clusterInfo = {enabled: false};\n\n  if (control) {\n    var cluster = require('cluster');\n    var version = control.VERSION;\n    if (version != null && semver.gte(version, '0.2.0')) {\n      self._strongClusterControl = control;\n\n      clusterInfo.enabled = !!control._running;\n      clusterInfo.isMaster = cluster.isMaster;\n      clusterInfo.isWorker = cluster.isWorker;\n\n      if (cluster.isMaster) {\n        this.notice('strong-agent using strong-cluster-control v%s', version);\n\n        // Repeating loop is so we don't lose sync on disconnect, should be a\n        // better way.\n        setInterval(updateClusterStatus, 5000).unref();\n\n        // On any state change which effects status, update it (for faster\n        // response on these infrequent events, we don't want to wait 5 seconds\n        // to know a worker has died).\n        cluster.on('fork', updateClusterStatus);\n        cluster.on('exit', updateClusterStatus);\n        cluster.on('disconnect', updateClusterStatus);\n        control.on('setSize', updateClusterStatus);\n        control.on('resize', updateClusterStatus);\n        control.on('restart', updateClusterStatus);\n        control.on('startRestart', updateClusterStatus);\n        control.on('start', updateClusterStatus);\n        control.on('stop', updateClusterStatus);\n\n        self.internal.on('cluster:resize', resizeCluster);\n        self.internal.on('cluster:restart-all', restartCluster);\n        self.internal.on('cluster:terminate', terminateWorker);\n        self.internal.on('cluster:shutdown', shutdownWorker);\n      }\n    } else {\n      this.notice('strong-agent cannot use strong-cluster-control %s,',\n                  'please update to >= 0.2.0');\n    }\n  }\n\n  // XXX(sam) It would be possible to display state of a cluster master (workers\n  // and change in worker status) even if control wasn't running.\n  sendClusterStatus();\n\n  return;\n\n  // XXX(sam) I think all the (!control || !clusterInfo.isMaster) guards below\n  // are unnecessary (though harmless).\n  function updateClusterStatus() {\n    if (!control || !clusterInfo.isMaster) {\n      return;\n    }\n    var status = control.status();\n    clusterInfo.setSize = control.options.size;\n    clusterInfo.size = status.workers.length;\n    clusterInfo.workers = status.workers;\n    clusterInfo.restarting = control._restartIds;\n    clusterInfo.cpus = control.CPUS;\n    clusterInfo.enabled = !!control._running;\n    sendClusterStatus();\n  }\n\n  function sendClusterStatus() {\n    self.internal.emit('cluster:status', clusterInfo);\n  }\n\n  function resizeCluster(size) {\n    if (!control || !clusterInfo.isMaster) return;\n    control.setSize(size);\n  }\n\n  function restartCluster() {\n    if (!control || !clusterInfo.isMaster) return;\n    control.restart();\n  }\n\n  function shutdownWorker(id) {\n    if (!control || !clusterInfo.isMaster) return;\n    control.shutdown(id);\n  }\n\n  function terminateWorker(id) {\n    if (!control || !clusterInfo.isMaster) return;\n    control.terminate(id);\n  }\n};\n\nAgent.prototype.metric = function(name, value) {\n  if (!this.started) return;\n  metrics.add(name, value);\n};\n\n// Generic debug logging\nAgent.prototype.debug = debug;\n\nAgent.prototype.info = function() {\n  this.config.logger.info('strong-agent[%d]', process.pid,\n                          util.format.apply(util, arguments));\n};\n\nAgent.prototype.warn = function() {\n  this.config.logger.warn('strong-agent[%d]', process.pid,\n                          util.format.apply(util, arguments));\n};\n\n// Notice level can be silenced with quiet option to .profile(). supervisor uses\n// this to not log the same startup information for every worker. It should be\n// used for one-time per application notifications.\nAgent.prototype.notice = function() {\n  if (!this.quiet) {\n    this.config.logger.log('strong-agent', util.format.apply(util, arguments));\n  }\n};\n\nAgent.prototype.error = function(e) {\n  if (e) {\n    // Note that `e` is not necessarily an Error, thus the check for .stack\n    this.config.logger.error('strong-agent error:', e.stack || e);\n  }\n};\n\n// Returns `this` on success or undefined on error for parity with .profile().\nAgent.prototype.use = function(callback) {\n  if (!this.licensed('metrics')) {\n    this.notice([\n      (this.config.key\n           ? 'agent metrics license not found, local reporting disabled.'\n           : 'not profiling, agent metrics requires a valid license.'),\n      'Please contact sales@strongloop.com for assistance.',\n    ].join('\\n'));\n    return;\n  }\n\n  this.start();\n\n  this.internal.on('watchdogActivationCount', function(count) {\n    callback('watchdog.activations.count', count);\n  });\n\n  this.internal.on('stats', function(stat, value, type) {\n    switch (type) {\n      case 'timer':\n        return callback(stat + '.timer', value / 1e6 /*ns->ms*/);\n      case 'count':\n        return callback(stat + '.count', value);\n      default:\n        return callback(stat, value);\n    }\n  });\n\n  this.internal.on('counts', function(counts) {\n    var labels = {\n      strongmq_in: 'messages.in.count',\n      strongmq_out: 'messages.out.count',\n    };\n    for (var key in counts) {\n      var label = labels[key] || (key + '.count');\n      callback(label, counts[key]);\n    }\n  });\n\n  this.internal.on('loop', function(metrics) {\n    callback('loop.count', metrics.count | 0);\n    callback('loop.minimum', metrics.fastest_ms | 0);\n    callback('loop.maximum', metrics.slowest_ms | 0);\n    callback('loop.average', fix(metrics.sum_ms / (metrics.count || 1)));\n  });\n\n  this.internal.on('instances', function(records) {\n    records.forEach(function(e) {\n      callback('object.' + e.type + '.count', e.total | 0);\n      callback('object.' + e.type + '.size', e.size | 0);\n    });\n  });\n\n  this.internal.on('tiers', function(data) {\n    for (var key in data) {\n      // Keys look like 'mongodb_in' or 'redis_out' or just 'http'\n      // or 'some.host.fqdn_out' or '12.34.56.78:8080_out'\n      var stats = data[key];\n      // if the key contains an '_':\n      //  => the name is 'tiers.' +  everything BEFORE the _\n      // else:\n      //  => the name is the key as-is.\n      var last = key.indexOf('_');\n      var name = (last < 0 ? key : 'tiers.' + key.slice(0, last));\n      callback(name + '.average', fix(stats.mean));\n      callback(name + '.maximum', fix(stats.max));\n      callback(name + '.minimum', fix(stats.min));\n    }\n  });\n\n  this.internal.on('metrics', function(data) {\n    for (var name in data) {\n      metric(name, data[name]);\n    }\n  });\n\n  function metric(name, value) {\n    if (name === 'CPU util') {\n      callback('cpu.total', fix(value));\n      return;\n    }\n\n    if (name === 'CPU util stime') {\n      callback('cpu.system', fix(value));\n      return;\n    }\n\n    if (name === 'CPU util utime') {\n      callback('cpu.user', fix(value));\n      return;\n    }\n\n    if (name === 'Heap Data') {\n      // Convert fractional MBs to bytes.\n      callback('heap.used', value[0] * 0x100000 | 0);\n      callback('heap.total', value[1] * 0x100000 | 0);\n      return;\n    }\n\n    // FIXME(bnoordhuis) Contrary to what the name suggests, this metric is\n    // actually a mix of scavenges and full GCs.\n    if (name === 'GC Full. V8 heap used') {\n      callback('gc.heap.used', value * 0x100000 | 0);\n      return;\n    }\n\n    if (name === 'Connections') {\n      // Index 0 is the number of open connections.\n      // Index 1 is the new connections/sec rate over the last interval.\n      // Index 2 is the number of new connections in the last interval.\n      // Index 3 is the number of new connections in the interval before that.\n      var curr = value[2] | 0;\n      var prev = value[3] | 0;\n      callback('http.connection.count', curr - prev);\n      return;\n    }\n  }\n\n  // Reduce the fraction of a floating point number to a fixed quantity\n  // so that e.g. 0.6317000000000004 becomes 0.6317.\n  function fix(value) { return +(+value).toFixed(5); }\n\n  return this;\n};\n\nAgent.prototype.dyninst = function(stream) {\n  var decoder = stream.pipe(json.JsonDecoder());\n  decoder.on('data', ondata);\n  var encoder = json.JsonEncoder();\n  encoder.pipe(stream);\n  function ondata(cmd) { dyninst.driver().submit(cmd, onresult); }\n  function onresult(err, result) {\n    if (err) {\n      result = {error: err.message, stack: err.stack};\n    }\n    if (result) {\n      encoder.write(result);\n    }\n  }\n};\n\nAgent.prototype.transactionLink = function(linkName, callback) {\n  if (!this.strongTracerInstrument) return callback;\n  debug(\"linkName:\", linkName);\n  return this.strongTracerInstrument.transactionLink(linkName, callback);\n};\n\nAgent.prototype.strongTraceLink = function(dbId, query, args){\n  var linkName = dbId + ' ' + query;\n  var callbackIndex = -1;\n  for(callbackIndex = args.length - 1; callbackIndex >= 0; callbackIndex--){\n    if (typeof args[callbackIndex] === 'function') {\n      args[callbackIndex] = this.transactionLink(linkName, args[callbackIndex]);\n      break;\n    }\n  }\n  if (callbackIndex === -1) {\n    [].push.call(args, this.transactionLink(linkName, function(){}));\n  }\n}\n\nfunction Metrics(agent) {\n  this.agent = agent;\n  this.stats = customStats.init(agent);\n}\n\n// Return an object with an error property on failure, nothing on success.\nMetrics.prototype.startCpuProfiling = function(timeout) {\n  checkCpuProfSupported(addon);\n  if (timeout && !this.agent.licensed('watchdog')) {\n    throw Error('Watchdog CPU profiling mode requires license');\n  }\n  if (timeout)\n    this.agent.info('starting cpu profiler (watchdog set to %s ms)', timeout);\n  else\n    this.agent.info('starting cpu profiler');\n  var errmsg = addon.startCpuProfiling(timeout);\n  if (errmsg) {\n    throw Error(errmsg);\n  }\n};\n\n// Return an object with an error property on failure, a (probably quite\n// large) JSON encoded string on success.\nMetrics.prototype.stopCpuProfiling = function() {\n  checkCpuProfSupported(addon);\n  var profile = addon.stopCpuProfilingAndSerialize();\n  if (!profile) {\n    throw Error('CPU profiler not started');\n  }\n  this.agent.info('stopping cpu profiler');\n  return profile;\n};\n\nMetrics.prototype.startTrackingObjects = function() {\n  if (!this.agent.licensed('metrics')) {\n    throw Error('Object tracking requires license');\n  }\n  this.agent.start();\n  this.agent.internal.emit('memory:start');\n  return addon != null;\n};\n\nMetrics.prototype.stopTrackingObjects = function() {\n  this.agent.start();\n  this.agent.internal.emit('memory:stop');\n};\n\n// Expose only to tests\nObject.defineProperty(Metrics.prototype, '_checkCpuProfSupported',\n{value: checkCpuProfSupported});\n\n// Return errorish object if profiling not supported, null if it is\nfunction checkCpuProfSupported(addon) {\n  if (!addon) {\n    throw Error(\"CPU profiler unavailable without compiled add-on\");\n  }\n  if (addon.stopCpuProfilingAndSerialize) {\n    return null;\n  }\n  throw Error(\"CPU profiler unavailable on Node.js \" + process.version);\n}\n\n\nmodule.exports = new Agent;\nmodule.exports.Agent = Agent;\nmodule.exports.require = require;\n\nObject.defineProperty(global, 'STRONGAGENT', {value: module.exports});\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/addon.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\ntry {\n  module.exports = require('../build/Release/strong-agent');\n} catch (e) {\n  try {\n    module.exports = require('../build/Debug/strong-agent');\n  } catch (e) {\n    module.exports = null;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/config.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar extend = require('util')._extend;\nvar os = require('os');\n\nvar defaults = {\n  baseInterval: 15 * 1000,\n};\n\n/**\n * Cascading config loader\n *\n * Search order:\n *   arguments\n *   process.env\n *   ./strongloop.json\n *   ./package.json\n *   ~/strongloop.json\n *\n * @param   {string} [key]      [API Key]\n * @param   {string} [appName]  [Name to identify app with in dashboard]\n * @returns {object} [Returns config data]\n */\nfunction configure(userKey, appName, options, env) {\n  var home =\n          process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,\n      cwd = process.cwd(), nfjson, pkgjson, userjson;\n  var slLicenses;\n\n  // Load configs from strongloop.json and package.json\n  try {\n    nfjson = require(cwd + '/strongloop.json');\n  } catch (e) {\n    nfjson = {};\n  }\n  try {\n    pkgjson = require(cwd + '/package.json');\n  } catch (e) {\n    pkgjson = {};\n  }\n  try {\n    userjson = require(home + '/strongloop.json');\n  } catch (e) {\n    userjson = {};\n  }\n  try {\n    // this is normally done by strongloop-license, but its API\n    // isn't quite flexible enough to use in strong-agent yet\n    slLicenses = require(home + '/.strongloop/licenses.json')\n                    .licenses.map(function(l) {\n                      return l.licenseKey;\n                    });\n  } catch (e) {\n    slLicenses = [];\n  }\n\n  var config = {\n    key: userKey || env.STRONGLOOP_KEY || env.SL_KEY ||\n             env.NODEFLY_APPLICATION_KEY || nfjson.userKey ||\n             pkgjson.strongAgentKey ||\n             userjson.key ||  // Bug-for-bug backwards compatibility...\n             userjson.userKey,\n\n    appName: appName || env.STRONGLOOP_APPNAME || env.SL_APP_NAME ||\n                 nfjson.appName || pkgjson.name || userjson.appName,\n\n    license: options.license || env.STRONGLOOP_LICENSE ||\n                 env.STRONG_AGENT_LICENSE || nfjson.agent_license || '',\n\n    logger: options.logger || console,\n  };\n\n  // add licenses found in ~/.strongloop/licenses.json\n  // and make config.license an Array of licenses\n  config.license = (config.license || '').split(':')\n                      .concat(slLicenses)\n                      .filter(function(l) {\n                        return !!l;\n                      });\n\n  appName = config.appName;\n\n  if (appName instanceof Array) {\n    config.appName = appName.shift();\n    config.hostname = appName.join(':');\n  } else {\n    config.hostname = os.hostname();\n  }\n\n  var result = extend(extend({}, defaults), config);\n  if (options.interval) {\n    result.baseInterval = options.interval;\n  }\n  return result;\n}\n\nmodule.exports = defaults;\nmodule.exports.configure = configure;\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/counts.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar counts = null;\n\nexports.sample = function(code) {\n  counts = counts || {};\n  counts[code] = 1 + (counts[code] | 0);\n};\n\nexports.poll = function() {\n  var snapshot = counts;\n  counts = null;\n  return snapshot;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/cpuinfo.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar trace = require('./debug')('cpu:trace');\nvar debug = require('./debug')('cpu');\n\nvar addon = require('./addon');\nvar proc = require('./proc');\nvar platform = require('os').platform();\nvar util = require('util');\n\nvar last =\n    {valid: false, all: 0, ptime: 0, utime: 0, stime: 0, uptime: 0, active: 0};\n\nfunction reportMetrics(proc, user, syst, onMetric) {\n  // There's a weird bug, on OS X if not elsewhere, either from floating-point\n  // calculations, or clock drift, or something that's leading to negative CPU\n  // readings in some cases; -2.960594732333751e-15 and so on.\n  // Pretty sure this only affects the system time, but we're going to round\n  // them all because having a negative CPU % doesn't make sense.\n\n  debug('reportMetrics  -  proc: %s, user: %s, syst: %s', proc, user, syst);\n\n  if ((proc < 0) || !isFinite(proc)) {\n    proc = 0;\n  }\n  if ((user < 0) || !isFinite(user)) {\n    user = 0;\n  }\n  if ((syst < 0) || !isFinite(syst)) {\n    syst = 0;\n  }\n\n  if (onMetric) {\n    debug('actually reported  -  proc: %s, user: %s, syst: %s', proc, user,\n          syst);\n    onMetric(proc, user, syst);\n  }\n}\n\nfunction calculateMetrics(utime, stime, ptime, all, onMetric) {\n  debug('calculateMetrics  -  utime: %s, ptime: %s, stime: %s, all: %s', utime,\n        ptime, stime, all);\n  if (last.valid) {\n    var tickDelta = (all - last.all);\n\n    if (tickDelta == 0) {\n      // no ticks have elapsed, so these readings are all invalid; just return\n      return;\n    }\n\n    var proc = (ptime - last.ptime) / tickDelta * 100;\n    var user = (utime - last.utime) / tickDelta * 100;\n    var syst = (stime - last.stime) / tickDelta * 100;\n\n    reportMetrics(proc, user, syst, onMetric);\n  } else {\n    debug('last not valid, not reporting');\n  }\n\n  last.valid = true;\n  last.all = all;\n  last.ptime = ptime;\n  last.utime = utime;\n  last.stime = stime;\n}\n\n// used for OS X and FreeBSD\nfunction parsePs(fields, pid, onMetric) {\n  // Use try/catch for\n  // - spawn because of https://github.com/joyent/node/issues/7453\n  // - console.error because of https://github.com/joyent/node/issues/7455\n  try {\n    var ps =\n        require('child_process').spawn('/bin/ps', ['-p', pid, '-o', fields]);\n  } catch (err) {\n    try {\n      console.error('strong-agent failed to get cpu usage:', err);\n    } catch (err) {\n      // On OS X, sometimes you can't write to stderr without allocating a\n      // kqueue fd.\n    }\n    return;\n  }\n  if (ps.unref) {\n    ps.unref();\n  }\n  var res = '';\n  ps.stdout.on('data', function(data) { res += data; });\n  ps.on('error', function(err) {\n    console.error('strong-agent failed to get cpu usage:', err);\n  });\n  ps.on('close', function() {\n    var re = RegExp('ELAPSED\\\\s*(\\\\d*):(\\\\d*\\\\.\\\\d*)\\\\s*(\\\\d*):' +\n                    '(\\\\d*\\\\.\\\\d*)\\\\s*(?:(\\\\d*)-)?(?:(\\\\d*):)?(\\\\d*):(\\\\d*)');\n    var m = res.match(re);\n    trace('ps is:\\n%s', res);\n\n    if (m) {\n      m.shift();  // toss the full match\n\n      var keys = [\n        'uMinutes',\n        'uSeconds',\n        'pMinutes',\n        'pSeconds',\n        'rDays',\n        'rHours',\n        'rMinutes',\n        'rSeconds'\n      ];\n\n      var data = m.reduce(function(memo, val) {\n        memo[keys.shift()] = parseFloat(val) || 0;\n        return memo;\n      }, {});\n\n      var utime = data.uMinutes * 60 + data.uSeconds;\n      var ptime = data.pMinutes * 60 + data.pSeconds;\n      var stime = ptime - utime;\n\n      var all = data.rDays * 86400 + data.rHours * 3600 + data.rMinutes * 60 +\n                data.rSeconds;\n\n      calculateMetrics(utime, stime, ptime, all, onMetric);\n    } else {\n      debug('unparsable ps data');\n    }\n  });\n}\n\nexports.cpuutil = function(onMetric) {\n  var pid = process.pid;\n\n  var metrics = addon && addon.cputime();\n  if (metrics) {\n    var utime = metrics[0];\n    var stime = metrics[1];\n    var ptime = utime + stime;\n    var all = process.uptime();\n    calculateMetrics(utime, stime, ptime, all, onMetric);\n    return;\n  }\n\n  if (platform === 'linux') {\n    debug('platform is linux');\n\n    proc.stat(pid, function(err, stat) {\n      if (err) {\n        return console.error('strong-agent failed to get cpu usage:', err);\n      }\n      trace('stat is\\n', util.inspect(stat));\n      calculateMetrics(stat.utime, stat.stime, stat.ptime, stat.all, onMetric);\n    });\n\n  } else if (platform === 'sunos' || platform === 'solaris') {\n    debug('platform is sunos/solaris');\n\n    proc.usage(pid, function(err, usage) {\n      if (err) {\n        return console.error('strong-agent failed to get cpu usage:', err);\n      }\n      var utime = usage.utime;\n      var stime = usage.stime;\n      var ptime = utime + stime;\n      var all = usage.rtime;\n\n      calculateMetrics(utime, stime, ptime, all, onMetric);\n    });\n\n  } else if (platform === 'darwin') {\n    debug('platform is darwin');\n\n    parsePs('utime,time,etime', pid, onMetric);\n\n  } else if (platform === 'freebsd') {\n    debug('platform is freebsd');\n\n    parsePs('usertime,time,etime', pid, onMetric);\n\n  } else if (platform === 'win32') {\n    debug('platform is win32');\n\n    if (last.uptime) {\n      var ps = require('child_process').exec('tasklist /v',\n                                             function(err, stdout, stderr) {\n        if (!err) {\n          stdout.split('\\n').forEach(function(item) {\n            var items = item.split(/\\s+/);\n            var pid = parseInt(items[1]);\n            if (pid === process.pid) {\n              var times = items[8].split(/[:.]/);\n\n              var hour = parseInt(times[0]);\n              var mins = parseInt(times[1]);\n              var secs = parseInt(times[2]);\n\n              // Total CPU Time of Process in Seconds\n              var active = hour * 3600 + mins * 60 + secs;\n\n              // Total Uptime of Process in Seconds\n              var uptime = process.uptime();\n\n              var uptimeDelta = uptime - last.uptime;\n              var activeDelta = active - last.active;\n\n              last.active = active;\n              last.uptime = uptime;\n\n              var usage = activeDelta / uptimeDelta;\n\n              if (uptimeDelta > 0) {\n                if (usage > 1) {\n                  // Spike Alert\n                }\n                reportMetrics(usage * 100, usage * 100, 0, onMetric);\n              }\n            }\n          })\n        }\n      });\n      ps.on('error', function(err) {\n        console.error('strong-agent failed to get cpu usage:', err);\n      });\n    } else {\n      last.uptime = process.uptime();\n    }\n\n  }  // if win32\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/debug.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n// Common debug wrapper. Its used by modules that do not have a reference to the\n// agent object, or want to debug under a particular section.\n//\n// Usage:\n//\n//   // In greetings module\n//   var debug = require('./debug')('greeter');\n//\n//   debug('yo, eh');\n//\n// Enable friendly greeting with one of:\n//   DEBUG='*'\n//   DEBUG='strong-agent:*'\n//   DEBUG='strong-agent:greeter'\n//\n// To avoid expensive argument preparation, you can do:\n//\n//   var debug = require('./debug')('section');\n//\n//   if (debug.enabled) {\n//     debug('%s', prepData()); // avoid prepData call if possible\n//   }\n\n'use strict';\n\nvar debug = require('debug');\n\nmodule.exports = function(section) {\n  var specification = 'strong-agent';\n\n  if (section) {\n    specification += ':' + section;\n  }\n\n  return debug(specification);\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/proc.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar fs = require('fs');\n\n//\n// This gets all messed up on 64-bit Solaris because the initial version assumed\n// 32 bits for all longs.  If this module ever get used for anything *other*\n// than Solaris, you'll want to verify that the sizes of these types are\n// still valid.\n//\n// typedef struct  timespec {        /* definition per POSIX.4 */\n//   time_t          tv_sec;         /* seconds */\n//   long            tv_nsec;        /* and nanoseconds */\n// } timespec_t;\n// ...\n// typedef long    time_t;         /* time of day in seconds */\n\nvar sizeof_long = 4;  // 32-bit\nvar sizeof_timespec = 8;\nif (process.arch == 'x64') {\n  sizeof_long = 8;\n  sizeof_timespec = 16;\n}\n\nfunction readTimespec(buf, offset) {\n  // this would be pretty janky for 64-bit, but because that 32-bit timestamp\n  // isn't going to hit the 64-bit space until 2037, it's Good Enough[tm]\n  return buf.readInt32LE(offset) +\n         (buf.readInt32LE(offset + sizeof_long) / 1000000000);\n}\n\nexports.usage = function usage(pid, callback) {\n\n  fs.readFile('/proc/' + pid + '/usage', function(err, buf) {\n    if (err) {\n      return callback(err, null);\n    };\n\n    var data = {};\n    var offset = 0;\n\n    // lwp id.  0: process or defunct\n    data.lwpid = buf.readUInt32LE(offset);\n    offset += 4;\n\n    // number of contributing lwps\n    data.count = buf.readUInt32LE(offset);\n    offset += 4;\n\n    // current time stamp\n    data.tstamp = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // process/lwp creation time stamp\n    data.create = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // process/lwp termination time stamp\n    data.term = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // total lwp real (elapsed) time\n    data.rtime = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // user level cpu time\n    data.utime = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // system call cpu time\n    data.stime = readTimespec(buf, offset);\n    offset += sizeof_timespec;\n\n    // there's normally another big pile of values we could read, but\n    // don't need any of them\n\n    callback(null, data);\n  });\n};\n\n// we only check this on linux, need to make sure that the field numbers\n// are valid on other platforms if we want to use it there as well\n\nexports.stat =\n    function stat(pid, callback) {\n\n      fs.readFile('/proc/' + pid + '/stat', 'ascii', function(err, data) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        var stats_pid = data.split(' ');\n        var ret = {};\n\n        ret.utime = parseInt(stats_pid[13]);\n        ret.stime = parseInt(stats_pid[14]);\n        ret.ptime = ret.utime + ret.stime;\n\n        fs.readFile('/proc/stat', 'ascii', function(err, data) {\n          if (err) return;\n\n          ret.all = data.match('cpu +(.*)\\n')[1].split(' ');\n          ret.all = array_sum(ret.all);\n\n          callback(null, ret);\n        })\n      });\n\n    }\n\nfunction array_sum(a) {\n  var k, s = 0;\n  if (typeof a !== 'object') return null;\n  for (k in a) {\n    s += (a[k] * 1);\n  }\n  return s;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/custom-stats.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nexports.init = function init(agent) {\n  function report(stat, value, type) {\n    agent.internal.emit('stats', 'custom.' + stat, value, type);\n  }\n\n  var counters = Object.create(null);\n\n  function count(stat, change) {\n    var latest = counters[stat] = (counters[stat] | 0) + change;\n    report(stat, latest, 'count');\n  }\n\n  exports.increment = function increment(stat) { count(stat, +1); };\n\n  exports.decrement = function decrement(stat) { count(stat, -1); };\n\n  function StatTimer(stat) {\n    this._stat = stat;\n    this._start = process.hrtime();\n  };\n\n  StatTimer.prototype.stop = function stop() {\n    if (!this._start) return;  // Timer stopped multiple times!\n\n    // Use full resolution ns internally, it will be converted to ms if reported\n    // to statsd.\n    var diff = process.hrtime(this._start);\n    var delta = diff[0] * 1e9 + diff[1];\n\n    this._start = undefined;\n\n    report(this._stat, delta, 'timer');\n  };\n\n  exports.createTimer =\n      function createTimer(stat) { return new StatTimer(stat); };\n\n  return exports;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/dyninst.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n// Copyright (c) 2014, StrongLoop Inc.\n//\n// This software is covered by the StrongLoop License.  See StrongLoop-LICENSE\n// in the top-level directory or visit http://strongloop.com/license.\n\n'use strict';\n\nvar assert = require('assert');\n\nmodule.exports = {\n  debug: debug,\n  driver: driver,\n  patch: patch,\n  position: position,\n  scripts: scripts,\n  unpatch: unpatch,\n};\n\n// Get access to Debug, an alternative to `node --expose_debug_as=D`/`D.Debug`.\nfunction debug() {\n  if (debug.instance == null) {\n    // vm.runInDebugContext() is pending joyent/node#8233.\n    var runInDebugContext = require('vm').runInDebugContext;\n    if (runInDebugContext == null) {\n      var addon = require('./addon');\n      runInDebugContext = addon && addon.runInDebugContext;\n    }\n    if (runInDebugContext == null) {\n      throw Error('add-on not loaded');\n    }\n    debug.instance = runInDebugContext('Debug');\n  }\n  return debug.instance;\n}\ndebug.instance = null;\n\nfunction scripts() {\n  var Debug = debug();\n  try {\n    return Debug.scripts();\n  } catch (e) {\n    if (e !== 'illegal access') throw e;\n    // Set a dummy event listener to stop debug functions from throwing\n    // illegal access errors because the debugger hasn't been started yet.\n    debug().setListener(function() {});\n    var result = Debug.scripts();\n    debug().setListener(undefined);\n    return result;\n  }\n}\n\nfunction patch(f) {\n  if (typeof(f) === 'function') {\n    return Functions.patch.apply(this, arguments);\n  } else {\n    return Scripts.patch.apply(this, arguments);\n  }\n}\n\nfunction unpatch(f) {\n  if (typeof(f) === 'function') {\n    return Functions.unpatch.apply(this, arguments);\n  } else {\n    return Scripts.unpatch.apply(this, arguments);\n  }\n}\n\n// `script` is a script object, from Debug.scripts().\n//\n// A script can be found from a name by using debug().findScript(pat), where\n// pat is either a function, a regexp applied to the script name, or the\n// exact script name.\nfunction position(script, lineno, column) {\n  if (lineno < 0) throw Error('Line number < 0');\n  if (column < 0) throw Error('Column number < 0');\n  lineno -= 1;\n  var pos = column;\n  var eols = script.line_ends;\n  if (lineno >= eols.length) return -1;\n  // XXX(bnoordhuis) Do we care if there is a newline between |pos - column|\n  // and |pos|?\n  if (lineno >= 0) pos += 1 + eols[lineno];\n  // |pos <= script.source.length| is not an off-by-one error; we allow\n  // insertion at the end of the script.\n  return pos <= script.source.length ? pos : -1;\n}\n\nfunction Functions() {}\nfunction Scripts() {}\n\nFunctions.patch =\n    function(f, config) { return Functions.commit(f, config, Scripts.patch); };\n\nFunctions.unpatch = function(f, config) {\n  return Functions.commit(f, config, function(script, changes) {\n    if (config && config.epilog) {\n      // Fix-up: adjust epilog offset.\n      if (config.prolog) {\n        changes[2] -= config.prolog.length;\n        changes[2] -= config.epilog.length;\n      } else {\n        changes[0] -= config.epilog.length;\n      }\n    }\n    return Scripts.unpatch(script, changes);\n  });\n};\n\n// Find function f, and patch config.prolog and config.epilog into its body\n// prolog goes right after the opening brace, and epilog right before the\n// closing brace.\nFunctions.commit = function(f, config, commit) {\n  var script = debug().findScript(f);\n  assert(script, 'cannot find script ' + f);\n  var changes = [];\n  var pos = debug().sourcePosition(f);\n  if (config && config.prolog) {\n    var index = 1 + script.source.indexOf('{', pos);\n    changes.push(index, config.prolog);\n  }\n  if (config && config.epilog) {\n    var index = pos + debug().source(f).length - 1;\n    changes.push(index, config.epilog);\n  }\n  return commit(script, changes);\n};\n\n// `script` is a script object, changes is an array of character offsets into\n// the script source, alternating with the code to be inserted at that offset.\nScripts.patch = function(script, changes) {\n  var diff = [];\n  var start = 0;\n  var offset = 0;\n  var chunks = [];\n  var source = script.source;\n  // We can't use Debug.LiveEdit.SetScriptSource() because it creates the\n  // diff using a tokenizer that eats curly braces.  Calculate the diff\n  // ourselves, it's a list of (pos1_start, pos1_end, pos2_end) tuples.\n  for (var i = 0, n = changes.length; i + 2 <= n; i += 2) {\n    var pos = changes[i + 0], change = changes[i + 1];\n    offset += change.length;\n    diff.push(pos, pos, pos + offset);\n    chunks.push(source.slice(start, pos));\n    chunks.push(change);\n    start = pos;\n  }\n  chunks.push(source.slice(start));\n  return Scripts.commit(script, chunks, diff);\n};\n\nScripts.unpatch = function(script, changes) {\n  var diff = [];\n  var start = 0;\n  var offset = 0;\n  var chunks = [];\n  var source = script.source;\n  var removed = 0;\n  for (var i = 0, n = changes.length; i + 2 <= n; i += 2) {\n    var pos = changes[i + 0], change = changes[i + 1];\n    pos += offset;\n    offset += change.length;\n    if (start < pos) {\n      chunks.push(source.slice(start, pos));\n      diff.push(pos, pos + change.length, pos - removed);\n    }\n    start = pos + change.length;\n    removed += change.length;\n  }\n  chunks.push(source.slice(start));\n  return Scripts.commit(script, chunks, diff);\n};\n\nScripts.commit = function(script, chunks, diff) {\n  var changelog = [];\n  var replacement = chunks.join('');\n  var LiveEdit = debug().LiveEdit;\n  try {\n    var result = LiveEdit.ApplyPatchMultiChunk(script, diff, replacement,\n                                               false,  // no preview\n                                               changelog);\n    return [result, changelog];\n  } catch (ex) {\n    // Repackage failures, they are not instances of Error.\n    if (ex instanceof LiveEdit.Failure) {\n      // |details| is available in V8 3.15.8 (i.e. node v0.11) and, if present,\n      // contains the syntax error object.\n      var details = ex.details;\n      ex = Error(ex.message);\n      ex.details = details;\n    }\n    throw ex;\n  }\n};\n\nfunction driver() {\n  return driver.singleton || (driver.singleton = new Driver);\n}\ndriver.singleton = null;\n\nfunction Driver() {\n  this.patches_ = Object.create(null);\n  this.patchids_ = 0;\n}\n\nDriver.prototype = {\n  patch: Driver$patch,\n  scripts: Driver$scripts,\n  sources: Driver$sources,\n  submit: Driver$submit,\n  unpatch: Driver$unpatch,\n};\n\nDriver.prototype.commands = Object.create(null);\n\nfunction Driver$patch(cmd, cont) {\n  var scriptid = cmd.scriptid | 0;\n  if (scriptid === 0) {\n    return fail(cont, 'No scriptid.');\n  }\n  var script = findscript(scriptid);\n  if (script == null) {\n    return fail(cont, 'No such script.');\n  }\n  var changes = cmd.changes;\n  if (Array.isArray(changes) === false) {\n    return fail(cont, 'No changes.');\n  }\n  if (changes.length % 2 !== 0) {\n    return fail(cont, 'Malformed changes.');\n  }\n  for (var i = 0, n = changes.length; i < n; i += 2) {\n    if (changes[i] !== changes[i] | 0) {\n      return fail(cont, 'Malformed changes: position is not a number.');\n    }\n    if (typeof(changes[i + 1]) !== 'string') {\n      return fail(cont, 'Malformed changes: change is not a string.');\n    }\n  }\n  var patch = {id: ++this.patchids_, changes: cmd.changes, script: script};\n  var result = Scripts.patch(patch.script, patch.changes);\n  if (result[0].change_tree.status !== 'source changed') {\n    // Patch didn't apply; explain why.\n    return fail(cont, result[0].change_tree.children[0].status_explanation);\n  }\n  this.patches_[patch.id] = patch;\n  defer(cont, null, {\n    patchid: patch.id,\n    result: result[0],\n    changelog: result[1],\n  });\n}\n\nfunction Driver$scripts(_, cont) {\n  function sort(a, b) { return a.id - b.id }\n  function map(s) { return [s.id, s.name || ''] }\n  defer(cont, null, flatmap(scripts().sort(sort).map(map)));\n}\n\nfunction Driver$sources(cmd, cont) {\n  if (Array.isArray(cmd.scriptids) === false) {\n    return fail(cont, 'No scriptids.');\n  }\n  var scripts = cmd.scriptids.map(findscript).map(function(script) {\n    return script ? [script.source, script.line_ends] : [null, null];\n  });\n  defer(cont, null, flatmap(scripts));\n}\n\nfunction Driver$submit(cmd, cont) {\n  if (cmd.version !== 0) {\n    return fail(cont, 'Protocol not supported.');\n  }\n  if (-1 === ['patch', 'scripts', 'sources', 'unpatch'].indexOf(cmd.cmd)) {\n    return fail(cont, 'Bad command: ' + cmd.cmd);\n  }\n  try {\n    this[cmd.cmd](cmd, cont);\n  } catch (ex) {\n    defer(cont, ex);\n  }\n}\n\nfunction Driver$unpatch(cmd, cont) {\n  var patch = this.patches_[cmd.patchid | 0];\n  if (patch == null) {\n    return fail(cont, 'No such patch.');\n  }\n  // Find newer patches for the same script.\n  var patches = [];\n  for (var patchid in this.patches_) {\n    var that = this.patches_[patchid];\n    if (that.id >= patch.id && that.script.id === patch.script.id) {\n      patches.push(that);\n    }\n  }\n  // Sort in descending order.\n  patches = patches.sort(function(a, b) { return b.id - a.id });\n  // And un-appply them in that order.\n  patches.forEach(\n      function(patch) { Scripts.unpatch(patch.script, patch.changes); });\n  // Now apply them again except for the first one,\n  // that's the patch we want to drop.\n  patches.reverse().slice(1).forEach(\n      function(patch) { Scripts.patch(patch.script, patch.changes); });\n  delete this.patches_[patch.id];\n  defer(cont);\n}\n\nfunction flatmap(lst) { return [].concat.apply([], lst); }\n\nfunction findscript(id) {\n  return scripts().filter(function(s) { return s.id === id })[0];\n}\n\nfunction fail(f, s) { defer(f, Error(s)); }\n\nfunction defer(f) { process.nextTick(f.bind.apply(f, arguments)); }\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/dyninst-metrics.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar assert = require('assert');\nvar debug = require('./debug')('dyninst-metrics');\nvar util = require('util');\n\nexports.init = function init(agent, dyninst) {\n  exports.findScript = findScript;\n  exports.patchLine = patchLine;\n  exports.patch = patch;\n\n  // name is a regex string long enough to uniquely match a script name.\n  //\n  // Script names are fully qualified when loaded using node require,\n  // and short when builtin to node ('util.js').\n  //\n  // Return is a debug script object if a unique match was found, null\n  // otherwise.\n  function findScript(name) {\n    var re = RegExp(name);\n    var scripts = dyninst.scripts().filter(function(script) {\n      return re.test(script.name);\n    });\n    // Mirrors what V8's Debug.findScript(re) does.\n    return scripts.length === 1 ? scripts[0] : undefined;\n  }\n\n  // line is 1-base (first line is line 1), patch is literal code to insert\n  // at beginning of line\n  function patchLine(name, line, patch) {\n    var script = findScript(name);\n\n    if (!script) throw Error('noscript');\n\n    var position = dyninst.debug().findScriptSourcePosition(script, line - 1);\n\n    if (position == null) throw Error('noline');\n\n    debug('patch script %s line %d pos %d: %j', script.name, line, position,\n          patch);\n    var changes = [position, patch];\n\n    return dyninst.patch(script, changes);\n  }\n\n  // patchset looks like:\n  //\n  //   {\n  //     NAME: [ PATCH, ...],\n  //     ...\n  //   }\n  //\n  // NAME is a regular expression matching filename to patch\n  //\n  // PATCH looks like:\n  //   {\n  //     type: TYPE,\n  //     line: LINE,\n  //     [metric: METRIC]\n  //     [code: CODE,]\n  //     [context: CTX,]\n  //   }\n  //\n  // For type:\n  // - code: code is literal code to insert\n  // - increment, decrement, timer-start, timer-stop:\n  //   - metric is dot-separated metric name\n  //\n  // XXX(sam) I could separate format checking from application of patch, to\n  // allow client to report verbose format errors without round-trip through\n  // supervisor/agent.\n  function patch(patchset) {\n    var name;\n    var patch;\n\n    try {\n      for (name in patchset) {\n        var patches = patchset[name];\n        patches.forEach(function(_) {\n          patch = _;\n          debug('patching %s: %j', name, patch);\n          assert(patch.type, 'patch for ' + name + ' has no type');\n          assert(patch.line, 'patch for ' + name + ' has no line');\n          switch (patch.type) {\n            case 'code':\n              assert(patch.code, 'nocode');\n              patchLine(name, patch.line, patch.code);\n              break;\n\n            case 'increment':\n            case 'decrement':\n              patchLine(name, patch.line, incdec(patch.type, patch.metric));\n              break;\n\n            case 'timer-start':\n              patchLine(name, patch.line,\n                        timerStart(patch.metric, patch.context));\n              break;\n\n            case 'timer-stop':\n              patchLine(name, patch.line, timerStop(patch.context));\n              break;\n\n            default:\n              throw Error('unsupported patch type: ' + patch.type);\n              break;\n          }\n        });\n      }\n    } catch (er) {\n      patch.file = name;\n      debug('patch failed: %s %j', er.message, patch);\n      // 'illegal access' exceptions are simple strings, not Error objects.\n      return {error: er.message || er, patch: patch};\n    }\n  }\n\n  function checkStatFormat(stat) {\n    if (stat == null) {\n      throw Error('stat is missing');\n    }\n    if (typeof stat !== 'string') {\n      throw Error('stat is not a string');\n    }\n    if (!/^\\w+(?:\\.\\w+)*$/.test(stat)) {\n      throw Error('stat is not dot-separated words');\n    }\n    return stat;\n  }\n\n  function checkContext(ctx) {\n    if (ctx == null) {\n      throw Error('context is missing');\n    }\n    if (typeof ctx !== 'string') {\n      throw Error('context is not a string');\n    }\n    // XXX(sam) not so clear what else we can check, validity as an assignment\n    // LHS depends on location of insertion\n    return ctx;\n  }\n\n  function incdec(call, stat) {\n    checkStatFormat(stat);\n    return util.format('global.STRONGAGENT.metrics.stats.%s(\\'%s\\');', call,\n                       stat);\n  }\n\n  // XXX(sam) try/catch will cause v8 to de-optimize the function, I could\n  // also pass all args to global.STRONGAGENT, and let it do the try/catch,\n  // or even wrap in an anonymous function. I'm not sure if this is a problem\n  // ATM, though.\n  function timerStart(stat, ctx) {\n    checkContext(ctx);\n    return util.format('try{%s.___timer = %s}catch(_){};', ctx,\n                       incdec('createTimer', stat));\n  }\n\n  function timerStop(ctx) {\n    checkContext(ctx);\n    return util.format('try{%s.___timer.stop()}catch(_){};', ctx);\n  }\n\n  return exports;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/graph-helper.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nmodule.exports = {\n\n  startNode: function startNode(name, q, agent) {\n    if (agent.graph == undefined) return;\n\n    var nodeId = agent.graph.nodes.length;\n    var node = {name: name, q: q, start: Date.now(), value: 1};\n    agent.graph.nodes.push(node);\n\n    var link = {source: agent.currentNode, target: nodeId, value: 1};\n    agent.graph.links.push(link);\n\n    var prevNode = agent.currentNode;\n    agent.currentNode = nodeId;\n\n    return {node: node, link: link, prevNode: prevNode};\n  },\n\n  updateTimes: function updateTimes(graphNode, time) {\n    if (graphNode == undefined) return;\n    graphNode.node.value = time.ms || 1;\n    graphNode.link.value = time.ms || 1;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/info.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar addon = require('./addon');\nvar cpuinfo = require('./cpuinfo');\n\nvar agent;\nvar gcstats = [];\nvar timebase;\n\nexports.init = function(agent_) {\n  agent = agent_;\n\n  if (!addon) {\n    return;\n  }\n\n  addon[addon.kGarbageCollectorStatisticsCallback] = function(samples) {\n    for (var i = 0, n = samples.length; i < n; i += 1) {\n      var len = gcstats.push(samples[i]);\n      var total = gcstats.reduce(function(a, b) { return a + b });\n      var baseline = total / len / 1e6;\n      agent.metric('GC Full. V8 heap used', baseline);\n      collectHeap(baseline);\n      if (len > 10) {\n        gcstats.shift();  // Sliding window.\n      }\n    }\n  };\n  addon.startGarbageCollectorStatistics();\n\n  timebase = Date.now();\n  collect();\n};\n\nexports.poll = function() {\n  collect();\n  connectionInfo();\n  collectHeap();\n};\n\nfunction collectHeap(gcFull) {\n  var rss = 0;\n  var heapUsed = 0;\n  try {\n    var mem = process.memoryUsage();\n    rss = mem.rss / 1000000;\n    heapUsed = mem.heapUsed / 1000000;\n  } catch (_) {\n    // Ignore. process.memoryUsage() can fail when the process\n    // has reached the open file descriptor limit.\n  }\n  var heapData = [heapUsed, rss, gcFull];\n  agent.metric('Heap Data', heapData);\n}\n\nfunction connectionInfo() {\n  // FIXME(bnoordhuis) Tracks only one HTTP server per process and it's not\n  // very deterministic what server that is...\n  var server = agent.httpServer;\n  if (server == null) return;\n  var kContextPropertyName = '__STRONGOPS_HTTP_CONTEXT__';\n  var context = server[kContextPropertyName];\n  var curr = context.connectionCounts[0];\n  var prev = context.connectionCounts[1];\n  context.connectionCounts[0] = 0;\n  context.connectionCounts[1] = curr;\n  if (server.getConnections) {\n    server.getConnections(callback);\n  } else {\n    callback(null, server.connections || server._connections || 0);\n  }\n  function callback(err, conns) {\n    if (err) return;\n    var now = Date.now();\n    var tps = curr / (now - timebase) / 1000;\n    timebase = now;\n    var metrics = [conns, tps, curr, prev];\n    agent.metric('Connections', metrics);\n  }\n}\n\nfunction collect() {\n  cpuinfo.cpuutil(function(percent_proc, percent_user, percent_syst) {\n    agent.metric('CPU util', percent_proc);\n    agent.metric('CPU util stime', percent_syst);\n    agent.metric('CPU util utime', percent_user);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/json.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n// Copyright (c) 2014, StrongLoop Inc.\n//\n// This software is covered by the StrongLoop License.  See StrongLoop-LICENSE\n// in the top-level directory or visit http://strongloop.com/license.\n\n'use strict';\n\nvar stream = require('stream');\nvar util = require('util');\n\nexports.JsonDecoder = JsonDecoder;\nexports.JsonEncoder = JsonEncoder;\n\n// |maxlen| is the amount of unparsed JSON data that may be buffered.\n// |maxlen| < 1 means 'unlimited'\n//\n// When the |maxlen| threshold is exceeded, an 'error' event is emitted on\n// the decoder object and the decoder stops parsing.  The decoder can then\n// be resumed by feeding it more data.\nfunction JsonDecoder(maxlen) {\n  if (!(this instanceof JsonDecoder)) return new JsonDecoder(maxlen);\n  this.constructor.call(this, {objectMode: true});\n  this.buffer_ = '';\n  this.index_ = 0;\n  this.maxlen_ = (maxlen | 0) || -1;\n  this.slice_ = null;\n}\n\nJsonDecoder.prototype = Object.create(stream.Transform.prototype);\n\nJsonDecoder.prototype._transform = function(chunk, encoding, done) {\n  this.buffer_ += chunk.toString();\n  for (;;) {\n    this.slice_ = null;\n    var index = this.buffer_.indexOf('\\n', this.index_);\n    if (index === -1) {\n      this.index_ = this.buffer_.length;\n      // Do the check now rather than before entering the loop.  If the new\n      // chunk causes the threshold to be exceeded but contains the newline\n      // that we're looking for, then we might as well parse the JSON.  But\n      // if there is still no newline, report a 'threshold exceeded' error.\n      if (this.maxlen_ > 0 && this.buffer_.length > this.maxlen_) {\n        var err = Error(util.format('Buffer size %d exceeds threshold.',\n                                    this.buffer_.length));\n        this.emit('error', err);\n        return done();\n      }\n      break;\n    }\n    var length = index + 1;\n    this.slice_ = this.buffer_.slice(0, length);\n    this.buffer_ = this.buffer_.slice(length);\n    this.index_ -= index;\n    if (length === 1) {  // A single newline is not a JSON object.\n      continue;\n    }\n    try {\n      var object = JSON.parse(this.slice_);\n      this.slice_ = null;\n    } catch (ex) {\n      var err = ex;\n      // Make the property non-enumerable so that printing the error object\n      // won't also print possibly megabytes of JSON data.\n      Object.defineProperty(err, 'data', {value: this.slice_});\n    }\n    if (err) {\n      this.emit('error', err);\n      err = null;\n    } else {\n      this.push(object);\n    }\n    if (this.paused) {\n      break;\n    }\n  }\n  done();\n};\n\nfunction JsonEncoder() {\n  if (!(this instanceof JsonEncoder)) return new JsonEncoder;\n  this.constructor.call(this, {objectMode: true});\n}\n\nJsonEncoder.prototype = Object.create(stream.Transform.prototype);\n\nJsonEncoder.prototype._transform = function(chunk, encoding, done) {\n  this.push(JSON.stringify(chunk) + '\\n', 'utf8');\n  done();\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/license.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar License = require('strong-license');\n\nmodule.exports = load;\n\nfunction load(key) {\n  return new License(key, 'c374fa24098c7eb64a73dc05c428be40');\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/loop.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar addon = require('./addon');\n\nexports.poll = function() {\n  if (!addon) {\n    return;\n  }\n  var statistics = addon.eventLoopStatistics;\n  var min = statistics[0];  // Can be UINT32_MAX but only when num === 0.\n  var max = statistics[1];\n  var num = statistics[2];\n  var sum = statistics[3];\n\n  statistics[0] = -1;  // Wraps around to UINT32_MAX.\n  statistics[1] = 0;\n  statistics[2] = 0;\n  statistics[3] = 0;\n\n  if (num === 0) {\n    return null;\n  }\n\n  // XXX(bnoordhuis) Backwards compatible field names.\n  // XXX(bnoordhuis) fastest_ms is new though.\n  return {count: num, fastest_ms: min, slowest_ms: max, sum_ms: sum};\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/metrics.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar metrics = null;\n\nexports.poll = function() {\n  var snapshot = metrics;\n  metrics = null;\n  return snapshot;\n};\n\nexports.add = function(name, value) {\n  if (metrics == null) {\n    // Users can add their own metrics; we need a prototype-less dictionary\n    // to store them or a metric like '__proto__' would cause issues.\n    metrics = Object.create(null);\n  }\n  metrics[name] = value;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/module-detector.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar path = require('path');\n\nmodule.exports.detectModule = detectModule;\nfunction detectModule(modulename, hasRun) {\n  var location;\n\n  try {\n    location = require.resolve(modulename);\n  } catch (err) {\n  }\n\n  if (location) {\n    location = path.dirname(location);\n    var version = require(path.resolve(location, 'package.json')).version;\n    return version;\n  } else if (!hasRun) {\n    return detectModule(path.resolve(process.cwd(), 'node_modules', modulename),\n                        true);\n  }\n  return null;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/proxy.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nmodule.exports = {\n  after: after,\n  around: around,\n  before: before,\n  callback: callback,\n  getter: getter,\n  init: init,\n  install: install,\n  oncall: oncall,\n  wrap: wrap,\n};\n\nvar kContextPropertyName = '__STRONGOPS_CONTEXT__';\n\nvar agent = null;\n\nfunction before(object, method, hook) { around(object, method, hook); }\n\nfunction after(object, method, hook) { around(object, method, null, hook); }\n\nfunction around(object, method, before, after) {\n  if (method instanceof Array) {\n    method.forEach(function(method) { around(object, method, before, after) });\n    return;\n  }\n  var all = descriptors(object, function(_, des) {\n    return des.configurable === true && 'function' === typeof(des.value);\n  });\n  var des = all[method];\n  if (des == null) {\n    return;  // No such property.\n  }\n  var target = des.value;\n  if (target == null) {\n    return;  // Getter or setter, don't touch.\n  }\n  if (isproxy(target)) {\n    var proxy = target;  // Already patched.\n  } else {\n    // Reuse a proxy if one already exists, else create a new one.\n    var des = first(all, function(_, des) {\n      return des && des.value && des.value[kContextPropertyName] &&\n             des.value[kContextPropertyName].target === target;\n    });\n    var proxy = des ? des.value : wrap(target);\n  }\n  var context = proxy[kContextPropertyName];\n  if (before && context.before.indexOf(before) === -1) {\n    context.before.push(before);\n  }\n  if (after && context.after.indexOf(after) === -1) {\n    context.after.push(after);\n  }\n  context.forward = recompile(context);\n  each(all, function(method, des) {\n    // This check filters out getters and that's intentional: a getter may have\n    // observable side effects and its return value need not be constant over\n    // time.  It's essentially a black box that can't be inspected.\n    if (des && des.value === target) install(object, method, des, proxy);\n  });\n}\n\nfunction callback(args, index, before, after) {\n  if (index === -1) {\n    index = args.length;\n    while (--index >= 0 && typeof(args[index]) !== 'function')\n      ;\n    if (index === -1) return;\n  }\n  var target = args[index];\n  var proxy = oncall(target, before, after);\n  args[index] = proxy;\n}\n\nfunction oncall(target, before, after) {\n  var extra = agent.extra;\n  var graph = agent.graph;\n  var currentNode = agent.currentNode;\n  var proxy = wrap(target, function(recv, args) {\n    // TODO(bnoordhuis) Get rid of these globals.\n    if (extra) agent.extra = extra;\n    if (graph) agent.graph = graph;\n    if (currentNode) agent.currentNode = currentNode;\n    if (before) before(recv, args, extra, graph, currentNode);\n    var rval = target.apply(recv, args);\n    if (after) after(recv, args, extra, graph, currentNode);\n    // TODO(bnoordhuis) Get rid of these globals.\n    if (currentNode) agent.currentNode = undefined;\n    if (graph) agent.graph = undefined;\n    if (extra) agent.extra = undefined;\n    return rval;\n  });\n  return proxy;\n}\n\nfunction getter(object, method, hook) {\n  if (method instanceof Array) {\n    method.forEach(function(method) { getter(object, method, hook) });\n    return;\n  }\n  var des = descriptor(object, method);\n  if (des == null) {\n    return;\n  }\n  if (des.get == null) {\n    return;  // Not a getter.\n  }\n  if (des.configurable === false) {\n    return;  // Immutable property.\n  }\n  if (isproxy(des.get)) {\n    var proxy = des.get;\n  } else {\n    var target = des.get;\n    var proxy = wrap(target);\n    var getters = descriptors(object, function(_, des) {\n      return des && des.get && des.get === target && des.configurable === true;\n    });\n    each(getters, function(method, des) {\n      Object.defineProperty(object, method, {\n        configurable: true,\n        enumerable: des.enumerable,\n        get: proxy,\n      });\n    });\n  }\n  var context = proxy[kContextPropertyName];\n  if (context.after.indexOf(hook) === -1) {\n    context.after.push(hook);\n  }\n  context.forward = recompile(context);\n}\n\nfunction init(agent_) { agent = agent_; }\n\nfunction each(dict, cb) {\n  Object.getOwnPropertyNames(dict)\n      .forEach(function(key) { cb(key, dict[key]); });\n}\n\nfunction first(dict, pred) {\n  try {\n    each(dict, function(key, value) {\n      if (pred(key, value)) throw value;\n    });\n  } catch (value) {\n    return value;\n  }\n}\n\nfunction descriptors(object, filter) {\n  function collect(object, collected) {\n    if (object == null || object === Array.prototype ||\n        object === Date.prototype || object === Function.prototype ||\n        object === Object.prototype) {\n      return collected;\n    }\n    collect(Object.getPrototypeOf(object), collected);\n    Object.getOwnPropertyNames(object).forEach(function(key) {\n      // Oracle's oracledb driver has write-only properties.\n      // Catch the errors and ignore them.\n      try {\n        var des = Object.getOwnPropertyDescriptor(object, key);\n        collected[key] = des;\n      } catch (e) {}\n    });\n    return collected;\n  }\n  var collected = collect(object, Object.create(null));\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    if (!filter(key, collected[key])) {\n      delete collected[key];\n    }\n  });\n  return collected;\n}\n\nfunction descriptor(object, method) {\n  do {\n    var des = Object.getOwnPropertyDescriptor(object, method);\n    object = Object.getPrototypeOf(object);\n  } while (des == null && object != null);\n  return des;\n}\n\nfunction isproxy(fun) {\n  return fun && fun.hasOwnProperty(kContextPropertyName);\n}\n\nfunction wrap(target, forward) {\n  if (isproxy(target)) {\n    return target;\n  }\n  var context = {\n    forward: forward,\n    target: target,\n    before: [],\n    after: [],\n  };\n  if (context.forward == null) {\n    context.forward = recompile(context);\n  }\n  // Generate a function with the same function name as the target.\n  var name = target.name;\n  if (name.length > 5 && name[5] === ' ') {\n    name = name.slice(6);  // Slice off 'bound ' from 'bound foo'.\n  } else if (name.length > 3 && name[3] === ' ') {\n    name = name.slice(4);  // Slice off 'get ' from 'get foo'.\n  }\n  var source = ' (function(context) {                          \\n' +\n               '   return function ' + name + '() {            \\n' +\n               '     return context.forward(this, arguments);  \\n' +\n               '   };                                          \\n' +\n               ' });                                           \\n';\n  var proxy = eval(source)(context);\n  Object.defineProperty(proxy, kContextPropertyName, {value: context});\n  // Make stringification yield the source of the target function.\n  Object.defineProperty(proxy, 'toString', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: function() { return '' + proxy[kContextPropertyName].target },\n  });\n  // Copy method annotations from the target (http, shared etc.)\n  Object.getOwnPropertyNames(target).forEach(function(k) {\n    var des = Object.getOwnPropertyDescriptor(target, k);\n    if (des.configurable) {\n      Object.defineProperty(proxy, k, des);\n    }\n  });\n  return proxy;\n}\n\nfunction recompile(context) {\n  var before = {values: context.before};\n  before.argnames = before.values.map(function(_, i) { return 'before' + i });\n  before.funcalls = before.values.map(function(f, i) {\n    var args = (f.length === 1 ? '(recv)' : '(recv, args)');\n    return before.argnames[i] + args;\n  });\n  var after = {values: context.after};\n  after.argnames = after.values.map(function(_, i) { return 'after' + i });\n  after.funcalls = after.values.map(function(f, i) {\n    var args = (f.length === 2 ? '(recv, rval)' : '(recv, args, rval)');\n    return after.argnames[i] + args;\n  });\n  var source = require('util').format(\n      ' (function(%s) {                                   \\n' +\n          '   return function(recv, args) {                   \\n' +\n          '     %s;                                           \\n' +\n          '     var rval = context.target.apply(recv, args);  \\n' +\n          '     %s;                                           \\n' +\n          '     return rval;                                  \\n' +\n          '   };                                              \\n' +\n          ' })                                                \\n',\n      ['context'].concat(before.argnames).concat(after.argnames),\n      before.funcalls.join(';\\n'), after.funcalls.join(';\\n'));\n  var args = [context].concat(before.values).concat(after.values);\n  return eval(source).apply(null, args);\n}\n\nfunction install(object, method, des, proxy) {\n  if (des.configurable === false) {\n    return;\n  }\n  var newdes = {\n    configurable: true,\n    enumerable: des.enumerable,\n    writable: des.writable,\n    value: proxy,\n  };\n  Object.defineProperty(object, method, newdes);\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/samples.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar Timer = require('./timer');\n\nmodule.exports.timer = function(scope, command) {\n  var t = new Timer(scope, command);\n  t.start();\n  return t;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/timer.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar assert = require('assert');\n// Store a reference in case the user clobbers the process or Math object.\nvar hrtime = process.hrtime;\nvar round = Math.round;\n\nfunction Timer(scope, command) {\n  this.scope = scope;\n  this.command = command;\n  this._start = undefined;\n  this.ms = 0;\n}\n\nTimer.prototype.start = function() { this._start = hrtime(); }\n\nTimer.prototype.end = function() {\n  var t = hrtime(this._start);\n  this.ms = t[0] * 1000 + t[1] / 1e6;\n};\n\nmodule.exports = Timer;\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/tiers.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nfunction Tiers() {\n  this.stats = null;\n}\n\nTiers.prototype.sample = function(code, time) {\n  var ms = time.ms;\n  var stat = null;\n  if (this.stats) {\n    stat = this.stats[code];\n  } else {\n    this.stats = {};\n  }\n  if (stat == null) {\n    this.stats[code] = {num: 1, mean: ms, min: ms, max: ms, sum: ms};\n  } else {\n    if (ms < stat.min) stat.min = ms;\n    if (ms > stat.max) stat.max = ms;\n    stat.num += 1;\n    stat.sum += ms;\n    stat.mean = stat.sum / stat.num;\n  }\n};\n\nTiers.prototype.poll = function() {\n  var snapshot = this.stats;\n  this.stats = null;\n  return snapshot;\n};\n\nmodule.exports = new Tiers;\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/top-functions.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar util = require('util');\n\nvar MAX_SIZE = 10;\n\nfunction TopFunctions() {\n  this._data = null;\n}\n\nTopFunctions.prototype.poll = function() {\n  var snapshot = this._data;\n  this._data = null;\n  return snapshot;\n};\n\nTopFunctions.prototype.add =\nfunction add(collectionName, url, ms, tiers, graph) {\n  var now = Date.now();\n  var data = [now, url, ms, tiers, graph];\n  var update = false;\n\n  if (this._data == null) {\n    this._data = {};\n  }\n\n  var list;\n  if (this._data[collectionName]) {\n    list = this._data[collectionName].list;\n  } else {\n    this._data[collectionName] = {\n      start: Date.now(),\n      collectionName: collectionName,\n      list: []\n    };\n    list = this._data[collectionName].list;\n  }\n\n  // on the list\n  var found = false;\n  list.forEach(function(item) {\n    if (item[1] == data[1]) {\n      found = true;\n      if (item[2] < data[2]) {\n        util._extend(item, data);\n        update = true;\n      }\n    }\n  });\n\n  // not on list\n  if (!found) {\n    // list has room\n    if (list.length < MAX_SIZE) {\n      list.push(data);\n      update = true;\n    } else {\n      // it ranks on list (it's walltime is greater than the last item on the\n      // list\n      if (data[2] > last(list)[2]) {\n        list.pop();\n        list.push(data);\n        update = true;\n      }\n    }\n  }\n\n  // we changed the content of the window, sort and emit time\n  if (update) {\n    list.sort(function(a, b) {\n      if (a[2] < b[2]) return 1;\n      if (a[2] == b[2]) return 0;\n      if (a[2] > b[2]) return -1;\n    });\n  }\n};\n\nmodule.exports = new TopFunctions();\n\nfunction last(l) {\n  if (l.length > 0)\n    return l[l.length-1];\n  else\n    return; // undefined\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/samples/app.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n// Copyright (c) 2014, StrongLoop Inc.\n//\n// This software is covered by the StrongLoop License.  See StrongLoop-LICENSE\n// in the top-level directory or visit http://strongloop.com/license.\n\nvar agent = require('../');\nvar http = require('http');\nvar net = require('net');\nvar path = require('path');\n\nnet.createServer(agent.dyninst).listen(7000);\nhttp.createServer(onrequest).listen(8000, onlisten);\n\nfunction onlisten() {\n  console.log('Listening on http://%s:%d/',\n              this.address().address,\n              this.address().port);\n  console.log('Now run `%s %s/di`',\n              process.argv[0],\n              path.relative(process.cwd(), __dirname) || '.');\n}\n\nfunction onrequest(req, res) {\n  res.writeHead(200, { 'Content-Length': '2' });\n  res.end('OK');\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/samples/di.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n// Copyright (c) 2014, StrongLoop Inc.\n//\n// This software is covered by the StrongLoop License.  See StrongLoop-LICENSE\n// in the top-level directory or visit http://strongloop.com/license.\n\nvar assert = require('assert');\nvar json = require('../lib/json');\nvar net = require('net');\nvar path = require('path');\n\n// This is the instrumentation that we are going to inject into the other\n// process.  It measures request/response times and sends off the metrics\n// to a server in this process.\n//\n// Note that instrumentation only has access to what is visible in the\n// lexical scope at the point of insertion: locals, globals and captured\n// (i.e. referenced) variables from enclosing scopes.  Variables from outer\n// scopes that are not referenced in the original function are not visible\n// to instrumentation; trying to inject code that references them will fail.\nvar instrumentation = (function() {\n  (function(agent, req, res) {\n    var socket = global.__DYNINST_SOCKET;\n    if (socket == null) {\n      socket = agent.require('dgram').createSocket('udp4');\n      socket.unref();\n      Object.defineProperty(global, '__DYNINST_SOCKET', { value: socket });\n    }\n    /* Keep references to the metrics we want to capture, they may have changed\n     * or gone away by the time we send off the datagram. */\n    var host = req.socket.remoteAddress;\n    var port = req.socket.remotePort;\n    var path = req.url;\n    var time = process.hrtime();\n    res.once('finish', function() {\n      time = process.hrtime(time);\n      var message = Buffer(JSON.stringify({\n        time: time[0] + time[1] / 1e6,\n        host: host,\n        port: port,\n        path: path,\n      }));\n      socket.send(message, 0, message.length, $PORT, '127.0.0.1');\n    });\n  })(STRONGAGENT, req, res);\n}).toString().slice(14, -2);\n\n// TODO(bnoordhuis) Could be minified further using e.g. uglifyjs.\ninstrumentation = instrumentation.trim().replace(/\\s+/g, ' ');\n\n// This is the server that receives the metrics.\nvar server = require('dgram').createSocket('udp4');\nserver.on('message', function(message) {\n  message = JSON.parse('' + message);\n  console.log('%s %d %j %d',\n              message.host,\n              message.port,\n              message.path,\n              message.time);\n});\nserver.bind(0);\n\nnet.connect(7000).once('connect', function() {\n  var socket = this;\n  var reader = json.JsonDecoder();\n  var writer = json.JsonEncoder();\n  socket.pipe(reader);\n  writer.pipe(socket);\n  step0();\n\n  // First find all the scripts.\n  function step0() {\n    writer.write({ cmd: 'scripts', version: 0 });\n    reader.once('data', step1);\n  }\n\n  // Now find the script that we want to patch, app.js.\n  function step1(scripts) {\n    assert.equal(Array.isArray(scripts), true);\n    assert.equal(scripts.length % 2, 0);\n    var scriptname = path.join(__dirname, 'app.js');\n    var scriptid = -1;\n    for (var i = 0, n = scripts.length; i < n; i += 2) {\n      if (scriptname !== scripts[i + 1]) continue;\n      scriptid = scripts[i + 0];\n      break;\n    }\n    if (scriptid === -1) {\n      throw Error('No script for ' + scriptname);\n    }\n    writer.write({ cmd: 'sources', scriptids: [scriptid], version: 0 });\n    reader.once('data', step2.bind(null, scriptid));\n  }\n\n  // Find the position in the source where we want to inject our code.\n  function step2(scriptid, sources) {\n    var source = sources[0];\n    var eols = sources[1];\n    var pos = source.indexOf('function onrequest');\n    var eol = eols.filter(function(npos) { return pos < npos })[0];\n    var change = instrumentation.replace(/\\$PORT/g, server.address().port);\n    if (change === source.slice(eol - change.length, eol)) {\n      console.log('Already instrumented.');\n      return done();\n    }\n    var changes = [eol, change];\n    writer.write({ cmd: 'patch', changes: changes,\n                   scriptid: scriptid, version: 0 });\n    reader.once('data', step3);\n  }\n\n  // Check that the patch applied.\n  function step3(result) {\n    if (result.error) {\n      var err = new Error(result.error);\n      err.stack = result.stack;  // Error stack from other process.\n      throw err;\n    }\n    var changelog = result.changelog;\n    for (var i = 0, n = changelog.length; i < n; i += 1) {\n      if (changelog[i].function_patched === 'onrequest') {\n        console.log('Instrumented.  Now start making requests.');\n        return done();\n      }\n    }\n    console.error('Instrumentation FAILED:', result);\n    done();\n  }\n\n  function done() {\n    socket.destroy();\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/axon.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar proxy = require('../proxy');\nvar counts = require('../counts');\n\n// Assumes following usage suggested in the README:\n// ```\n// var pub = require('axon').socket('pub');\n// var sub = require('axon').socket('sub');\n// ```\n\n// TODO(rmg): Support PubEmitter/SubEmitter, it doesn't use the same\n//            send()/on('message') pattern as the others:\n//            https://github.com/visionmedia/axon#pubemitter--subemitter\n\nmodule.exports = function(axon) {\n\n  // TODO(rmg): Instrument axon.Socket.prototype instead?\n  proxy.after(axon, 'socket', function(obj, args, socket) {\n\n    proxy.after(socket, 'send', function(obj, args) {\n      // When MQ metrics were first added to StrongOps it was for StrongMQ\n      // specifically, so the metric names have been immortalized\n      counts.sample('strongmq_out');\n    });\n\n    proxy.before(socket, ['on', 'addListener'], function(obj, args) {\n      var event = args[0];\n\n      // TODO(rmg): PubEmitter/SubEmitter allows user-defined events\n      if (event !== 'message') return;\n\n      proxy.callback(args, -1, function(obj, args, extra) {\n        // When MQ metrics were first added to StrongOps it was for StrongMQ\n        // specifically, so the metric names have been immortalized\n        counts.sample('strongmq_in');\n      });\n    });\n\n  });\n\n  return axon;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/express.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar topFunctions = require('../top-functions');\n\nmodule.exports = function(express) {\n\n  // set up route on server init\n  function routeHook(obj, args, router) {\n    var method = args[0].toUpperCase();\n    var path = args[1];\n    var route;\n\n    // start request\n    proxy.callback(args, -1, function(obj, args) {\n      if (agent.paused) return;\n\n      var req = args[0];\n      var res = args[1];\n      var timer = samples.timer(\"Express Server\", path, true);\n\n      // finish request\n      proxy.after(res, 'end', function(obj, args) {\n        timer.end();\n\n        route = route || (method + ' ' +\n                          (res.app.route === '/' ? '' : res.app.route) + path);\n        topFunctions.add('expressCalls', route, timer.ms, req.tiers, req.graph);\n      });\n    });\n  }\n\n  if (express.Router) {  // express 3.x exposes the Router class directly\n    proxy.before(express.Router.prototype, ['route'], routeHook);\n  } else {  // express 2.x exposes the router object once the server is created\n    proxy.after(express, 'createServer', function(obj, args, app) {\n      proxy.before(app.routes, ['_route'], routeHook);\n    });\n  }\n\n  return express;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/http.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar util = require('util');\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\nmodule.exports = function(http) {\n  var config = agent.config;\n\n  // server probe\n  proxy.before(http.Server.prototype, ['on', 'addListener'],\n               function(server, args) {\n\n    // store ref to server so we can pull current connections\n    agent.httpServer = server;\n\n    var kContextPropertyName = '__STRONGOPS_HTTP_CONTEXT__';\n    var context = server[kContextPropertyName];\n    if (context == null) {\n      // Index [0] is current connection counter, [1] is the previous one.\n      context = {connectionCounts: [0, 0]};\n      Object.defineProperty(server, kContextPropertyName, {value: context});\n    }\n\n    if (args[0] !== 'request' && args[0] !== 'upgrade') return;\n\n    proxy.callback(args, -1, function(obj, args) {\n      context.connectionCounts[0] += 1;\n\n      if (agent.paused) return;\n\n      var req = args[0];\n      var res = args[1];\n      var timer = samples.timer(\"HTTP Server\", req.url, true);\n      req.tiers = timer.tiers = agent.extra = {};\n\n      var graph = agent.graph = {nodes: [{name: req.url}], links: []};\n      req.graph = graph;\n      var currentNode = agent.currentNode = 0;\n\n      proxy.after(res, 'end', function(obj, args) {\n        timer.end();\n\n        graph.nodes[0].value = timer.ms;\n        topFunctions.add('httpCalls', req.url, timer.ms, timer.tiers, graph);\n        tiers.sample('http', timer);\n\n        timer.tiers.closed = true;\n      });\n    });\n  });\n\n  // client probe\n  function getClientResponseHandler(url, host, timer, graphNode) {\n    return function handleResponseCb(obj, args, extra) {\n      var res = args[0];\n\n      proxy.before(res, ['on', 'addListener', 'once'], function(res, args) {\n        if (args[0] !== 'end') return;\n\n        proxy.callback(args, -1, function(obj, args, extra) {\n          timer.end();\n          // if (!time || !timer.done()) return;\n\n          topFunctions.add('externalCalls', url, timer.ms);\n          graphHelper.updateTimes(graphNode, timer);\n\n          if (extra) {\n            extra[host] = extra[host] || 0;\n            extra[host] += timer.ms;\n\n            if (extra.closed) {\n              if (typeof host === 'string') tiers.sample(host + '_out', timer);\n            } else {\n              if (typeof host === 'string') tiers.sample(host + '_in', timer);\n            }\n          }\n        });  // res end cb\n\n      });  // res end\n    }\n  }\n\n  // handle http.request with callback\n  proxy.before(http, 'request', function(obj, args) {\n    var opts = args[0];\n    var cb = args[1];\n\n    if (typeof cb != 'function') return;\n\n    if (opts.headers || opts._headers) {\n      // get the url\n      var headers = opts._headers || opts.headers;\n      var method = opts.method || '';\n      var host = headers.Host || headers.host || '';\n      var path = opts.path;\n      var url = util.format('%s http://%s%s', method, host, path);\n\n      var timer = samples.timer(\"HTTP Client\", url, true);\n      var graphNode = graphHelper.startNode('Outgoing HTTP', url, agent);\n\n      proxy.callback(args, -1,\n                     getClientResponseHandler(url, host, timer, graphNode));\n      if (graphNode) agent.currentNode = graphNode.prevNode;\n    }\n  });\n\n  // handle ClientRequest, evented.\n  if (http.ClientRequest && http.ClientRequest.prototype) {\n    proxy.before(http.ClientRequest.prototype, ['on', 'addListener', 'once'],\n                 function onResponse(req, args) {\n      if (args[0] !== 'response') return;\n\n      if (req._headers || req.headers) {\n        var headers = req._headers || req.headers;\n        var method = req.method || '';\n        var host = headers.Host || headers.host || '';\n        var path = req.path;\n        var url = util.format('%s http://%s%s', method, host, path);\n\n        var timer = samples.timer(\"HTTP Server\", url, true);\n        var graphNode = graphHelper.startNode('Outgoing HTTP', url, agent);\n\n        proxy.callback(args, -1,\n                       getClientResponseHandler(url, host, timer, graphNode));\n        if (graphNode) agent.currentNode = graphNode.prevNode;\n      }\n\n    });  // before on/add/once\n\n  }  // http.ClientRequest\n\n  return http;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/https.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nmodule.exports = require('./http');\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/leveldown.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\n/*\n * Instrumentation for LevelDB via leveldown module, which is the de facto\n * canonical module for LevelDB in Node.\n *\n * github: https://github.com/rvagg/node-leveldown\n * npm: https://npmjs.org/package/leveldown\n *\n */\nmodule.exports = function(leveldown) {\n  /*\n    This is leveldown, as we receive it:\n    leveldown()\n    leveldown.destroy()\n    leveldown.repair()\n\n    We wrap leveldown() to instrument the instance methods of the\n    returned Database object.\n\n    These are probably not worth instrumenting:\n    leveldown#open()\n    leveldown#close()\n\n    These are set up with timers below:\n    leveldown#put()\n    leveldown#get()\n    leveldown#del()\n\n    These should probably be timed:\n    leveldown#batch()\n    leveldown#approximateSize()\n    leveldown#getProperty()\n\n    Spy on #iterator() to attach instrumentation to each iterator instance\n    leveldown#iterator()\n    iterator#next()\n    iterator#end()\n  */\n\n  // leveldown()\n  function wrappedLeveldown(location) {\n    var db = leveldown(location);\n\n    function instrumentAsync(obj, args, method) {\n      if (agent.paused) {\n        return;\n      }\n\n      var time = samples.timer('LevelDown', method);\n      var graphNode = graphHelper.startNode('LevelDown', method, agent);\n      counts.sample('leveldown');\n\n      // get(key[, options], callback)\n      // put(key, value[, options], callback)\n      // del(key[, options], callback)\n      // batch(operations[, options], callback)\n      var key = (method == 'batch' ? args[0].length : args[0]);\n\n      var query = location + '.' + method + ':' + key;\n\n      function handle(obj, args, extra) {\n        time.end();\n\n        topFunctions.add('leveldownCalls', query, time.ms);\n        graphHelper.updateTimes(graphNode, time);\n\n        if (extra) {\n          extra.leveldown = extra.leveldown || 0;\n          extra.leveldown += time.ms;\n        }\n\n        tiers.sample('leveldown_in', time);\n      }\n\n      proxy.callback(args, -1, handle, null, true);\n      if (graphNode) {\n        agent.currentNode = graphNode.prevNode;\n      }\n    }\n\n    // TODO: Investigate if we should instead be attaching this instrumentaiton\n    //       on to Database's and Iterator's prototypes instead.\n\n    proxy.before(db, ['get', 'put', 'del', 'batch'], instrumentAsync);\n\n    proxy.after(db, 'iterator', function(obj, args, ret) {\n      proxy.before(ret, ['next', 'end'], instrumentAsync);\n    });\n\n    return db;\n  }\n\n  // Need to maintain leveldown's exported API\n  wrappedLeveldown.destroy = leveldown.destroy;\n  wrappedLeveldown.repair = leveldown.repair;\n\n  return wrappedLeveldown;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/loopback-datasource-juggler.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar samples = require('../samples');\nvar tiers = require('../tiers');\nvar proxy = require('../proxy');\nvar extend = require('util')._extend;\nvar topFunctions = require('../top-functions');\n\nvar commands = {\n  create: 'create',\n  findOrCreate: 'find_or_create',\n  exists: 'exists',\n  find: 'find',\n  findById: 'find_by_id',\n  remove: 'remove',\n  removeById: 'remove_by_id',\n  count: 'count'\n};\n\nvar instanceCommands = {\n  save: 'save',\n  remove: 'remove',\n  updateAttribute: 'update_attribute',\n  updateAttributes: 'update_attributes',\n  reload: 'reload'\n};\n\nmodule.exports = function(juggler) {\n  var dao = juggler.Schema.DataAccessObject;\n\n  function createPatcher(obj) {\n    return function patch(command) {\n      var _old = dao[command];\n      proxy.before(obj, command, function(obj, args) {\n        if (args.length === 0 ||\n            typeof args[args.length - 1] !== 'function') {\n          // TODO(bnoordhuis) loopback-datasource-juggler methods return\n          // promises when the callback is omitted.  We don't yet support\n          // instrumenting those.\n          return;\n        }\n        var cmd = commands[command];\n        agent.strongTraceLink('DAO', command, args);\n        var timer = samples.timer('DataAccessObject', cmd);\n        proxy.callback(args, -1,\n                       function(obj, args, extra, graph, currentNode) {\n          timer.end();\n          topFunctions.add('jugglerCall', command, timer.ms);\n          if (extra) {\n            extra.dao = extra.dao || 0;\n            extra.dao += timer.ms;\n            if (extra.closed) {\n              tiers.sample('dao_out', timer);\n            } else {\n              tiers.sample('dao_in', timer);\n            }\n          } else {\n            tiers.sample('dao_in', timer);\n          }\n        });\n      });\n      extend(dao[command], _old);\n    };\n  }\n\n  Object.keys(commands).forEach(createPatcher(dao));\n  Object.keys(instanceCommands).forEach(createPatcher(dao.prototype));\n\n  return juggler;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/memcached.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\nexports = module.exports = memcached;\nexports.getCommandAndKey = getCommandAndKey;\n\nvar commands = [\n  'get',\n  'gets',\n  'getMulti',\n  'set',\n  'replace',\n  'add',\n  'cas',\n  'append',\n  'prepend',\n  'increment',\n  'decrement',\n  'incr',\n  'decr',\n  'del',\n  'delete',\n  'version',\n  'flush',\n  'samples',\n  'slabs',\n  'items',\n  'flushAll',\n  'samplesSettings',\n  'samplesSlabs',\n  'samplesItems',\n  'cachedump'\n];\n\nfunction memcached(memcached) {\n\n  commands.forEach(function(command) {\n    proxy.before(memcached.prototype, command, function(client, args) {\n      if (agent.paused) return;\n\n      // ignore, getMulti will be called\n      if (command === 'get' && Array.isArray(args[0])) return;\n\n      var timer = samples.timer(\"Memcached\", command);\n      var graphNode = graphHelper.startNode('Memcached', command, agent);\n      counts.sample('memcached');\n\n      var query = command + ' ' + args[0];\n\n      function strongTraceTransaction(query, callback){\n        var linkName = \"Memcached \" + query;\n        return agent.transactionLink(linkName, callback);\n      }\n\n      function handle (obj, args, extra) {\n        timer.end();\n\n        topFunctions.add('memcacheCalls', query, timer.ms);\n        graphHelper.updateTimes(graphNode, timer);\n        if (extra) {\n          extra.memcached = extra.memcached || 0;\n          extra.memcached += timer.ms;\n          if (extra.closed) {\n            tiers.sample('memcached_out', timer);\n          } else {\n            tiers.sample('memcached_in', timer);\n          }\n        } else {\n          tiers.sample('memcached_in', timer);\n        }\n      }\n\n      proxy.callback(args, -1,\n        strongTraceTransaction(getCommandAndKey(command, args), handle));\n\n      if (graphNode) agent.currentNode = graphNode.prevNode;\n    });\n  });\n\n  return memcached;\n};\n\nfunction getCommandAndKey(command, args) {\n  var keyValue = '';\n  if (typeof args[0] === 'string') keyValue += ' \"' + args[0] + '\"';\n  if (typeof args[1] === 'string') keyValue += ' \"' + args[1] + '\"';\n  return command + keyValue;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/memcache.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\nvar memcached = require('./memcached');\n\nvar commands = [\n  'get',\n  'set',\n  'delete',\n  'add',\n  'replace',\n  'append',\n  'prepend',\n  'cas',\n  'increment',\n  'decrement',\n  'samples'\n];\n\nvar findCallback = function(args) {\n  for (var i = 0; i < args.length; i++)\n    if (typeof args[i] === 'function') return i;\n};\n\nmodule.exports = function(obj) {\n\n  function strongTraceInject(query, args){\n    var callbackIndex = args.length - 1;\n    if (typeof args[callbackIndex] === 'function') {\n      args[callbackIndex] =\n          strongTraceTransaction(query, args[callbackIndex]);\n    }\n  }\n\n  function strongTraceTransaction(query, callback){\n    var linkName = \"Memcache \" + query;\n    return agent.transactionLink(linkName, callback);\n  }\n\n  // connect\n  proxy.after(obj.Client.prototype, 'connect', function(obj, args, ret) {\n    obj.__timer__ = samples.timer(\"Memcached\", \"connect\");\n  });\n\n  proxy.before(obj.Client.prototype, 'on', function(obj, args) {\n    var client = obj;\n    var event = args[0];\n    if (event !== 'connect' && event !== 'timeout' && event !== 'error') return;\n\n    strongTraceInject(event, args);\n    proxy.callback(args, -1, function(obj, args) {\n      if (agent.paused) return;\n\n      var timer = client.__timer__;\n      // if(!time || !timer.done()) return;\n      timer.end();\n\n      // not doing anything with on connect/timeout/error events just yet\n    });\n  });\n\n  // commands\n  commands.forEach(function(command) {\n    proxy.before(obj.Client.prototype, command, function(client, args) {\n      if (agent.paused) return;\n\n      var timer = samples.timer(\"Memcached\", command);\n      counts.sample('memcached');\n\n      // there might be args after callback, need to do extra callback search\n      var pos = findCallback(args);\n      if (pos == undefined) return;\n\n      var query = command + ' ' + args[0];\n      var graphNode = graphHelper.startNode('Memcached', query, agent);\n\n      args[pos] =\n          strongTraceTransaction(memcached.getCommandAndKey(command, args),\n                                 args[pos]);\n\n      proxy.callback(args, pos, function(obj, args, extra) {\n        timer.end();\n\n        topFunctions.add('memcacheCalls', query, timer.ms);\n        graphHelper.updateTimes(graphNode, timer);\n        if (extra) {\n          extra.memcached = extra.memcached || 0;\n          extra.memcached += timer.ms;\n\n          if (extra.closed) {\n            tiers.sample('memcached_out', timer);\n          } else {\n            tiers.sample('memcached_in', timer);\n          }\n        } else {\n          tiers.sample('memcached_in', timer);\n        }\n      });  // callback\n\n      if (graphNode) agent.currentNode = graphNode.prevNode;\n    });\n  });\n\n  return obj;\n};  // exports\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/mongodb.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\nvar internalCommands = [\n  '_executeQueryCommand',\n  '_executeInsertCommand',\n  '_executeUpdateCommand',\n  '_executeRemoveCommand'\n];\n\nvar commandMap = {\n  '_executeQueryCommand': 'find',\n  '_executeInsertCommand': 'insert',\n  '_executeUpdateCommand': 'update',\n  '_executeRemoveCommand': 'remove'\n};\n\nvar tier = 'mongodb';\nfunction recordExtra(extra, timer) {\n  if (extra) {\n    extra[tier] = extra[tier] || 0;\n    extra[tier] += timer.ms;\n\n    if (extra.closed) {\n      tiers.sample(tier + '_out', timer);\n    } else {\n      tiers.sample(tier + '_in', timer);\n    }\n  } else {\n    tiers.sample(tier + '_in', timer);\n  }\n}\n\n// Map to convert query property types to sane defaults\nvar blank = {\n  '[object String]': '',\n  '[object Boolean]': false,\n  '[object Number]': 0,\n  '[object RegExp]': /.*/,\n  '[object Date]': new Date\n};\n\nvar toString = Object.prototype.toString;\n\nmodule.exports = function(mongodb) {\n  internalCommands.forEach(function(internalCommand) {\n    var cmd = commandMap[internalCommand];\n    proxy.before(mongodb.Collection.prototype, cmd, function(obj, args) {\n      var command = args[0] || {};\n      var q = typeof(command) === 'object' ?\n          JSON.stringify(command) : command.toString();\n      var fullQuery = cmd + '(' + q + ')';\n\n      function strongTraceTransaction(query, callback){\n        var linkName = \"MongoDB \" + query;\n        return agent.transactionLink(linkName, callback);\n      }\n\n      var timer = samples.timer(\"MongoDB\", commandMap[internalCommand]);\n\n      var callbackIndex = args.length - 1;\n      while (callbackIndex >= 0 && typeof(args[callbackIndex]) !== 'function') {\n        callbackIndex -= 1;\n      }\n\n      var graphNode = graphHelper.startNode('MongoDB', fullQuery, agent);\n      counts.sample('mongodb');\n\n      function mongoCalls(obj, args, extra, graph, currentNode) {\n        timer.end();\n        topFunctions.add('mongoCalls', fullQuery, timer.ms);\n        recordExtra(extra, timer);\n        graphHelper.updateTimes(graphNode, timer);\n      }\n\n      if (callbackIndex === -1) {\n        // updates and inserts are fire and forget unless safe is set\n        // record these in top functions, just for tracking\n        topFunctions.add('mongoCalls', fullQuery, 0);\n        tiers.sample(tier + '_in', timer);\n      } else {\n        args[callbackIndex] =\n            strongTraceTransaction(fullQuery, args[callbackIndex]);\n        proxy.callback(args, callbackIndex, mongoCalls);\n      }\n\n      if (graphNode) agent.currentNode = graphNode.prevNode;\n    });\n  });  // all commands\n\n  return mongodb;\n};     // require mongo\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/mysql.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar path = require('path');\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\n// |require_| is used by the test suite, lib/agent.js always passes undefined.\nmodule.exports = function(obj, require_) {\n\n  var Connection = findConnection(obj, require_ || require);\n  if (!Connection) {\n    agent.error('failed to instrument mysql');\n    return obj;\n  }\n\n  proxy.before(Connection.prototype, 'query', function(obj, args) {\n    if (agent.paused) return;\n\n    var command = args.length > 0 ? args[0] : undefined;\n\n    var params =\n        args.length > 1 && Array.isArray(args[1]) ? args[1] : undefined;\n    var timer = samples.timer(\"MySQL\", \"query\");\n\n    var graphNode = graphHelper.startNode('MySQL', command, agent);\n    counts.sample('mysql');\n\n    function handle(obj, args, extra, graph, currentNode) {\n      timer.end();\n      topFunctions.add('mysqlCalls', command, timer.ms);\n\n      graphHelper.updateTimes(graphNode, timer);\n\n      if (extra) {\n        extra.mysql = extra.mysql || 0;\n        extra.mysql += timer.ms;\n        if (extra.closed) {\n          tiers.sample('mysql_out', timer);\n        } else {\n          tiers.sample('mysql_in', timer);\n        }\n      } else {\n        tiers.sample('mysql_in', timer);\n      }\n    }\n\n    agent.strongTraceLink(\"MySQL\", command, args);\n    proxy.callback(args, -1, handle, null, true);\n\n    if (graphNode) agent.currentNode = graphNode.prevNode;\n  });\n\n  return obj;\n};\n\nfunction findConnection(mysql, require) {\n  var cache = require.cache;\n  for (var key in cache) {\n    var candidate = cache[key];\n    if (candidate.exports !== mysql) {\n      continue;\n    }\n    var dirname = path.dirname(candidate.filename);\n    var filename = path.join(dirname, 'lib', 'Connection.js');\n    try {\n      return require(filename);\n    } catch (e) {\n      return null;\n    }\n  }\n  return null;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/oracledb.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar topFunctions = require('../top-functions');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar graphHelper = require('../graph-helper');\n\nexports = module.exports = oracledb;\nexports.oracleBase = oracleBase;\n\nfunction oracledb(oracle) {\n  return oracleBase(oracle, 'getConnection', 'getConnection', 'Oracledb');\n}\n\nfunction oracleBase(oracle, connSyncCmd, connCmd, linkName) {\n\n  proxy.after(oracle, connSyncCmd, function(obj, args, connection) {\n    proxy_connection(connection, linkName);\n  });\n\n  proxy.before(oracle, connCmd, function(obj, args) {\n\n    agent.strongTraceLink(linkName, connCmd, args);\n    proxy.callback(args, -1, function (obj, args) {\n      var connection = args[1];\n      proxy_connection(connection, linkName);\n    });\n  });\n\n  return oracle;\n}\n\nfunction proxy_connection(connection, linkName) {\n  if (!connection) return;\n\n  proxy.around(\n      connection, 'executeSync',\n      // before\n      function(obj, args, locals) { query_before(args, locals, linkName); },\n      // after\n      function(obj, args, ret, locals) { query_after(locals); });\n\n  proxy.before(connection, ['execute'], function(obj, args) {\n    // query starts\n    var locals = {};\n    query_before(args, locals, linkName);\n\n    proxy.callback(args, -1, function(obj, args) {\n      // query ends\n      query_after(locals);\n    });\n  });\n\n  ['commit', 'rollback'].forEach(function(method) {\n    proxy.before(connection, method, function(obj, args) {\n      // query starts\n      var locals = {command: method};\n      query_before(args, locals, linkName);\n      proxy.callback(args, -1, function(obj, args, extra) {\n        // query ends\n        query_after(locals, extra);\n      });\n    });\n  });\n}\n\nfunction query_before(args, locals, linkName) {\n  locals.command = locals.command || (args.length > 0 ? args[0] : undefined);\n  locals.timer = samples.timer('Oracle', 'query');\n  locals.graphNode = graphHelper.startNode('Oracle', locals.command, agent);\n  if (locals.graphNode) {\n    agent.currentNode = locals.graphNode.prevNode;\n  }\n  counts.sample('oracle');\n  agent.strongTraceLink(linkName, locals.command, args);\n}\n\nfunction query_after(locals, extra) {\n  var tier = extra && extra.closed ? 'oracle_out' : 'oracle_in';\n  locals.timer.end();\n  topFunctions.add('oracleCalls', locals.command, locals.timer.ms);\n  graphHelper.updateTimes(locals.graphNode, locals.timer);\n  tiers.sample(tier, locals.timer);\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/pg.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\n// FIXME(bnoordhuis) Unclear if require('../agent') is for side effects.\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\n\nvar tier = 'postgres';\nfunction recordExtra(extra, timer) {\n  if (extra) {\n    extra[tier] = extra[tier] || 0;\n    extra[tier] += timer.ms;\n\n    if (extra.closed) {\n      tiers.sample(tier + '_out', timer);\n    } else {\n      tiers.sample(tier + '_in', timer);\n    }\n  } else {\n    tiers.sample(tier + '_in', timer);\n  }\n}\n\nmodule.exports = function(obj) {\n\n  function probe(obj) {\n    if (obj.__probeInstalled__) return;\n    obj.__probeInstalled__ = true;\n\n    function strongTraceTransaction(query, callback){\n      var linkName = \"PostgreSQL \" + query;\n      return agent.transactionLink(linkName, callback);\n    }\n\n    // Callback API\n    proxy.before(obj, 'query', function(obj, args, ret) {\n      var command = args.length > 0 ? args[0] : undefined;\n      var params =\n          args.length > 1 && Array.isArray(args[1]) ? args[1] : undefined;\n      var timer = samples.timer(\"PostgreSQL\", \"query\");\n      counts.sample('postgres');\n\n      function handleCallback(obj, args, extra) {\n        timer.end();\n\n        topFunctions.add('postgresCalls', command, timer.ms);\n        recordExtra(extra, timer);\n      }\n\n      proxy.callback(args, -1, strongTraceTransaction(command, handleCallback));\n    });\n\n    // Evented API\n    proxy.after(obj, 'query', function(obj, args, ret) {\n      // If has a callback, ignore\n      if (args.length > 0 && typeof args[args.length - 1] === 'function')\n        return;\n\n      var client = obj;\n      var command = args.length > 0 ? args[0] : undefined;\n      var params =\n          args.length > 1 && Array.isArray(args[1]) ? args[1] : undefined;\n      var timer = samples.timer(\"PostgreSQL\", \"query\");\n      counts.sample('postgres');\n\n      proxy.before(ret, 'on', function(obj, args) {\n        var event = args[0];\n        if (event !== 'end' && event !== 'error') return;\n\n        function handleEvent(obj, args, extra) {\n          timer.end();\n\n          topFunctions.add('postgresCalls', command, timer.ms);\n          recordExtra(extra, timer);\n        }\n\n        proxy.callback(args, -1, strongTraceTransaction(command, handleEvent));\n      });\n    });\n  }\n\n  // Native, reinitialize probe\n  proxy.getter(obj, 'native', function(obj, ret) {\n    proxy.after(ret, 'Client',\n                function(obj, args, ret) { probe(ret.__proto__); });\n  });\n\n  probe(obj.Client.prototype);\n\n  return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/redis.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar debug = require('../debug')('probes:redis');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\nmodule.exports = function(redis) {\n  var proto = redis.RedisClient.prototype;\n  if (typeof proto.internal_send_command === 'function') {\n    proxy.before(proto, 'internal_send_command', before);  // redis@>=2.6\n  } else {\n    proxy.before(proto, 'send_command', compat);  // redis@<2.6\n  }\n  return redis;\n};\n\nfunction compat(recv, args) {\n  var cmd = { command: args[0], args: args[1] };\n  before(recv, [cmd]);\n}\n\nfunction before(recv, args) {\n  if (agent.paused) return;\n\n  var cmd = args[0];\n  if (!cmd) return;\n\n  var command = cmd.command;\n  var input = cmd.args;\n\n  if (!Array.isArray(input)) return;\n\n  var timer = samples.timer('Redis', command);\n  var query = command +\n              (typeof input[0] === 'string' ? ' \"' + input[0] + '\"' : '');\n  var graphNode = graphHelper.startNode('Redis', query, agent);\n\n  counts.sample('redis');\n  debug('command: %s', command);\n\n  function handle(obj, args, extra) {\n    timer.end();\n\n    debug('%s callback', command);\n    topFunctions.add('redisCalls', query, timer.ms);\n    graphHelper.updateTimes(graphNode, timer);\n\n    if (extra) {\n      debug('%s extra: ', extra);\n      extra.redis = extra.redis || 0;\n      extra.redis += timer.ms;\n      tiers.sample(extra.closed ? 'redis_out' : 'redis_in', timer);\n    } else {\n      tiers.sample('redis_in', timer);\n    }\n  }\n\n  function getCommandAndKey(command, input){\n    while(Array.isArray(input)){\n      if (typeof input[0] === 'string') {\n        var keyValue = '\"' + input[0] + '\"';\n        if (typeof input[1] === 'string') keyValue += ' \"' + input[1] + '\"';\n        return command + \" \" + keyValue;\n      }\n      input = input[0];\n      continue;\n    }\n    return command;\n  }\n\n  function strongTraceTransaction(query, callback){\n    var linkName = \"Redis \" + query;\n    return agent.transactionLink(linkName, callback);\n  }\n\n  var des = Object.getOwnPropertyDescriptor(cmd, 'callback');\n  if (des && des.configurable) {\n    var callback = des.value;\n    if (typeof callback !== 'function') callback = function() {};\n    var interceptor = proxy.oncall(callback, handle);\n    proxy.install(cmd, 'callback', des, interceptor);\n  } else {\n    // Support send_command(com, [arg, cb]) and send_command(com, [arg], cb)\n    var callbackIndex = args.length - 1;\n    if (typeof args[callbackIndex] === 'function') {\n      args[callbackIndex] = strongTraceTransaction(\n        getCommandAndKey(command, input), args[callbackIndex]);\n      proxy.callback(args, callbackIndex, handle);\n    } else {\n      // Hack to support optional functions by adding noop function when\n      // blank\n      callbackIndex = input.length - 1;\n      if (typeof input[callbackIndex] !== 'function') {\n        input.push(function() {});\n        callbackIndex += 1;\n      }\n      input[callbackIndex] =\n          strongTraceTransaction(getCommandAndKey(command, input),\n                                 input[callbackIndex]);\n      proxy.callback(input, callbackIndex, handle);\n    }\n  }\n\n  if (graphNode) agent.currentNode = graphNode.prevNode;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/riak-js.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar samples = require('../samples');\nvar counts = require('../counts');\nvar tiers = require('../tiers');\nvar topFunctions = require('../top-functions');\nvar graphHelper = require('../graph-helper');\n\nmodule.exports = function(riak) {\n  proxy.after(riak, ['getClient'], function(obj, args, ret) {\n    var client = ret;\n    var clientType = args[0].api || \"http\";  // http or protobuf\n\n    proxy.before(client, ['get', 'save', 'head', 'exists', 'remove'],\n                 function(obj, args, method) {\n      if (agent.paused) {\n        return;\n      }\n\n      var time = samples.time(\"Riak\", method);\n      var graphNode = graphHelper.startNode('Riak', method, agent);\n      counts.sample('riak');\n\n      // get(): (bucket, key, options, callback)\n      // save(): (bucket, key, data, options, callback)\n      // head(): (bucket, key, options, callback)\n      // exists(): (bucket, key, options, callback) -> calls head()\n      // remove(): (bucket, key, options, callback)\n\n      var bucket = args.length > 0 ? args[0] : undefined;\n      var key = args.length > 1 ? args[1] : undefined;\n\n      // q = clientType.bucket.key.get()\n      var q = clientType + '.' + bucket + '.' + key + '.' + method;\n\n      function handle(obj, args, extra) {\n        if (!time.done()) return;\n\n        topFunctions.add('riakCalls', q, time.ms);\n        graphHelper.updateTimes(graphNode, time);\n\n        if (extra) {\n          extra.riak = extra.riak || 0;\n          extra.riak += time.ms;\n        }\n        tiers.sample('riak_in', time);\n      }\n\n      proxy.callback(args, -1, handle, null, true);\n      if (graphNode) agent.currentNode = graphNode.prevNode;\n    });\n  });\n\n  return riak;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/sl-mq.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nexports = module.exports = require('./strong-mq');\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/strong-mq.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\n// FIXME(bnoordhuis) Unclear if require('../agent') is for side effects.\nvar agent = require('../agent');\nvar proxy = require('../proxy');\nvar counts = require('../counts');\n\nmodule.exports = function(strongmq) {\n  proxy.after(strongmq, 'create', function(obj, args, connection) {\n    proxy.after(connection, ['createPushQueue', 'createPubQueue'],\n                function(obj, args, queue) {\n      proxy.after(queue, 'publish', function(obj, args, queue) {\n        counts.sample('strongmq_out');\n      });\n    });\n    proxy.after(connection, ['createPullQueue', 'createSubQueue'],\n                function(obj, args, queue) {\n      queue.on('message', function() { counts.sample('strongmq_in'); });\n    });\n  });\n\n  return strongmq;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/strong-cluster-control.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../agent');\n\nmodule.exports = function(control) {\n  agent.prepareClusterControls(control);\n  return control;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/strong-express-metrics.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar agent = require('../../');\n\nmodule.exports = function(xstats) {\n  xstats.onRecord(function(record) {\n    agent.internal.emit('express:usage-record', record);\n  });\n\n  return xstats;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/probes/strong-oracle.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar oracleBase = require('./oracledb').oracleBase;\nvar proxy = require('../proxy');\n\nfunction instrument(oracle) {\n  return oracleBase(oracle, 'connectSync', 'connect', 'StrongOracle');\n}\n\nmodule.exports = function oracle(exports) {\n  if (typeof exports !== 'function') {\n    return instrument(exports);  // Pre-1.2 strong-oracle.\n  }\n\n  return proxy.wrap(exports, function(recv, args) {\n    return instrument(exports.apply(recv, args));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/profilers/cpu.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar licensed;\n\n// addon is exposed so it may be monkey-patched by unit tests\nexports.addon = require('../addon');\n\nexports.init = function(agent) {\n  licensed = agent.licensed.bind(agent);\n};\n\n// A timeout > 0 starts the profiler in watchdog mode.  Watchdog mode pauses\n// the profiler until at least |timeout| milliseconds pass without the event\n// loop going through epoll_wait(), a reliable indicator that the program is\n// stalled on something.  Watchdog mode is currently implemented on i386 and\n// x86_64 Linux.\nexports.start = function(timeout) {\n  if (timeout && !licensed('watchdog')) {\n    throw Error('Watchdog CPU profiling mode requires license');\n  }\n  if (exports.addon == null) {\n    return false;\n  }\n  var errmsg = exports.addon.startCpuProfiling(timeout | 0);\n  if (errmsg) {\n    throw Error(errmsg);\n  }\n  exports.enabled = true;\n  return true;\n};\n\nexports.stop = function() {\n  exports.enabled = false;\n  return exports.addon && exports.addon.stopCpuProfiling();\n};\n","/home/travis/build/npmtest/node-npmtest-strong-agent/node_modules/strong-agent/lib/profilers/memory.js":"// Copyright IBM Corp. 2015. All Rights Reserved.\n// Node module: strong-agent\n// US Government Users Restricted Rights - Use, duplication or disclosure\n// restricted by GSA ADP Schedule Contract with IBM Corp.\n\n'use strict';\n\nvar debug = require('../debug')('profilers:memory');\n\nfunction Instances() {\n  this.addon = require('../addon');\n  this.agent = null;\n  this.enabled = false;\n}\nmodule.exports = new Instances;\n\nInstances.prototype.init = function(agent_) {\n  this.agent = agent_;\n};\n\nInstances.prototype.start = function() {\n  if (!this.addon) {\n    this.agent.info('could not start heap monitoring add-on');\n    return false;\n  }\n  debug('instance monitoring started');\n  this.addon.startHeapDiff();\n  this.enabled = true;\n  return true;\n};\n\nInstances.prototype.stop = function() {\n  if (!this.enabled) return;\n  debug('instance monitoring stopped');\n  this.addon.stopHeapDiff(false);\n  this.enabled = false;\n};\n\nInstances.prototype.poll = function() {\n  if (!this.enabled) return null;\n  var state = this.addon.stopHeapDiff(true);\n  this.addon.startHeapDiff();\n  return state;\n};\n"}